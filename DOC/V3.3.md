 PDF To Markdown Converter
Debug View
Result View
Microsoft Word - 1.docx
1. 概述与核心原则
本规范基于厂商最终确认的 PLC 行为、支付外设硬件特性及实际运营边界，明确定义 APP 状态
机、订单生命周期、设备控制职责与硬件抽象分层。
以下三条核心原则不可违反：
1.1 状态机驱动
 UI 仅根据 WashFlowState 渲染，绝不直接猜测或依赖设备瞬态值。
 任何设备事件（PLC 位变化、POS 交易结果、现金接收、打印机状态）必须通过事件/用例
推动状态迁移，禁止在 UI 层或订单层直接修改状态。
1.2 异步监控，非主动控制（洗车机）
 APP 不“控制”洗车过程，只负责发送启动请求和监控运行状态。
 启动指令为 写 MODE 寄存器（脉冲），PLC 自动清零，APP 禁止重复发送或回写 0 。
 运行中 APP 不干预 PLC 内部逻辑，仅监听 214/102/217 等状态位。
1.3 订单终态必须与服务完成绑定
 ❌ 发送 MODE 不代表订单完成
 ✅ 订单只有在“服务真实结束”或“明确终止策略完成后”才能关闭
 严禁出现“收钱未服务”或“已关单但服务未结束”的状态不一致。
2. 系统架构分层
系统分为四个逻辑层次，下层为上层提供标准化服务，严禁跨层调用。
2.1 层次定义
层次 职责 关键组件
设备层
与所有物理硬件直接交互，读取状态、发送指令，仅暴露
标准化接口给上层
PLC 驱动、现金驱动、POS 驱
动、打印机驱动等
状态管
理层
维护 APP 流程状态 WashFlowState，轮询设备，执行超时
策略，决策状态迁移
状态机引擎、轮询服务、计时器
订单层
维护订单生命周期 OrderState，关联支付交易、退款、财
务记录
订单服务、支付网关代理
UI 层 仅根据 WashFlowState 渲染界面，无任何业务逻辑 (^) 视图控制器、页面组件

2.2 设备层详细构成（V3.2 强化连接管理）
所有物理硬件驱动均位于 device/ 目录，按设备类别拆分模块，每个模块只负责本类硬件的指令
收发与状态上报，不包含任何业务流程逻辑。
2.2.1 设备驱动模块结构
text
DeviceLayer/
├── plc_driver/ # 洗车机 PLC
│ ├── plc_client.py # TCP/Modbus 通信封装
│ ├── registers.py # 寄存器地址定义（217/240/214/102/752/MODE/M60/M71）
│ └── plc_interface.py # 读状态、写MODE、M60/M
├── cash_device/ # 现金支付设备（纸币器+硬币器）
│ ├── driver/ # 底层通信协议（SSP 等）
│ ├── device_manager.py # 连接生命周期管理（单例，全局唯一）
│ ├── bill_acceptor.py # 纸币器专用接口（继承自 CashDeviceBase）
│ ├── coin_acceptor.py # 硬币器专用接口（继承自 CashDeviceBase）
│ └── cash_interface.py # 暴露给状态管理层的统一接口（含状态监测、收款、找零）
├── pos_terminal/ # POS 终端
│ ├── pos_serial.py # 串口/以太网通信
│ ├── pos_protocol.py # 交易/撤销/退款/查询指令
│ └── pos_interface.py # 支付、退款、结果回调、小票打印
├── printer/ # 热敏打印机
│ └── printer_driver.py # 打印小票/二维码/故障检测
└── voice/ # 语音播报（可选）
└── voice_player.py # 播放提示音、语音合成

2.2.2 纸币器/硬币器连接生命周期管理（厂商强制规范）
1. 建立连接
 APP 启动时，由 CashDeviceManager 负责调用一次 OpenConnection，与所有已识别设备
建立通信会话。
 连接成功后永久保持，禁止在支付流程中关闭或重新打开连接。
2. 状态监测
 必须使用 GetDeviceStatus 指令定期查询设备健康状态，不得依赖 HTTP 请求的超时或异
常来判定设备离线。
 轮询间隔严格控制在 350ms – 500ms，以平衡实时性与设备负载。
 设备层驱动只负责发送指令、接收响应、更新内部状态缓存；不负责重连决策。
3. 接收器控制(包含纸币器，硬币器)
 收款启用/禁用：通过 EnableAcceptor(true/false) 指令，无需断开连接。
 每笔新订单在支付会话开始、调用 EnableAcceptor(true) 之前，必须按顺序执行以下预
配置步骤：
1. 获取设备支持的所有面额列表
调用 GetCurrencyAssignment?deviceID=，从返回的每个条目中提
取 Value 和 CountryCode，组合成面额标识（如 "500 EUR"）。此列表将用于后续
的 inhibit 重置和设置。
2. 读取当前可找零库存明细
仍使用 GetCurrencyAssignment，但只关注 Stored 值（recycler 中的数量），忽
略 StoredInCashbox（现金箱中的货币不可用于找零）。得到库存映射：Map<面额
（分）, 数量>。
3. 重置所有面额的禁用状态
调用 SetDenominationInhibits?deviceID=，请求体包含步骤 1 获得的所有
面额列表，并将 Inhibit 设为 false。确保设备从干净状态开始，不受上次交易影
响。
4. 示例请求：
json
POST /api/CashDevice/SetDenominationInhibits?deviceID=SPECTRAL_PAYOUT-
{
"ValueCountryCodes": ["500 EUR", "1000 EUR", "2000 EUR"],
"Inhibit": false
}
5. 计算可安全接收的面额
对步骤 1 得到的每一种面额 value（分），若 value > targetCents（目标金
额），则需找零金额 change = value - targetCents。
使用动态规划算法（见附录 Aa）判断当前 recycler 库存能否精确组合出 change。
若无法精确找零，则将该面额加入禁用列表。
6. 设置本次交易禁用面额
再次调用 SetDenominationInhibits，传入步骤 4 计算出的禁用面额列表，
Inhibit=true。
7. 开启接收器
调用 EnableAcceptor(true)，并根据需要调用 SetAutoAccept(true)，开始接收
现金。
 支付结束时（无论成功或失败），调用 EnableAcceptor(false) 关闭接收器。
4. 库存读取
 支付过程中通过 GetAllLevels 获取库存变化，计算收款金额。
 严禁因 GetAllLevels 超时或失败而自动触发 OpenConnection。
 网络超时由状态管理层按策略处理（重试或超时退款）。
5. 异常处理
 设备层驱动应缓存最后一次 GetDeviceStatus 的结果，并提供 isDeviceOnline() 方法供
状态管理层查询。
 若连续多次 GetDeviceStatus 失败，状态管理层可判定设备离线，进入人工干预流程。
 设备层绝不自动重连，重连决策权在状态管理层（且仅在会话未激活且用户明确触发“重新
连接”时执行）。
附录 Aa：动态规划找零可行性算法（Kotlin 示例）
kotlin
/**

判断在给定库存下能否精确凑出金额 changeCents
@param changeCents 需要找零的金额（分）
@param inventory 当前 recycler 库存，Map<面额（分）, 数量>
@return true 表示可以精确找零
*/
fun canMakeChange(changeCents: Int, inventory: Map<Int, Int>): Boolean {
if (changeCents == 0 ) return true
val dp = BooleanArray(changeCents + 1 )
dp[ 0 ] = true
for ((value, count) in inventory) {
for (x in changeCents downTo 0 ) {
if (dp[x]) {
var total = x
repeat(count) {
total += value
if (total > changeCents) return@repeat
if (!dp[total]) dp[total] = true
}
}
}
}
return dp[changeCents]
}

2.2.3 设备层核心原则（强化版）
 只回答“硬件现在是什么状态/结果”，不回答“我应该做什么”。
 所有驱动必须提供同步/异步两种接口，以便状态管理层根据场景选择。
 错误通过统一错误码 + 详细消息上报，由状态管理层决策。
 必须提供模拟驱动实现，用于单元测试与脱机演示。
 严禁在设备层实现任何业务重试、自动重连、会话状态缓存等逻辑。
2.3 状态管理层与设备层的交互边界
状态管理层仅通过设备层暴露的标准化接口获取硬件状态或执行操作，绝不直接发送串口指令或解
析协议。
示例：现金支付交互（V3.2 规范）
状态管理层动作 调用的设备层接口 设备层职责
进入 Paying_Cash cash_device.enableAcceptor(true) 发送 EnableAcceptor 指令
轮询接收金额 cash_device.getAllLevels()^ 返回当前库存（异步/同步）^
用户确认支付 cash_device.collect()^ 将金额转入钱箱（执行收款）
执行找零 cash_device.dispenseChange(amount)^ 马达找零，返回找零结果
检测找零能力 cash_device.getChangeStatus()^ 返回能否找零、缺少面额
超时未投币 cash_device.enableAcceptor(false) 关闭接收器
定期监测设备状态 cash_device.getDeviceStatus() 返回设备在线/故障状态^
状态监测专用流程（独立于支付轮询）：
 状态管理层启动一个独立的定时任务（间隔 500ms），调
用 cash_device.getDeviceStatus() 更新所有现金设备的健康状态。
 若连续 3 次状态异常，状态管理层应立即禁用现金支付入口，并提示用户“现金设备故障，
请使用其他支付方式”。
2.4 订单层与设备层的关系
订单层绝不允许直接调用设备层接口。
订单层只与状态管理层或云端支付网关代理通信，所有交易凭证由状态管理层传递后存储。
3. 状态机定义
3.1 设备状态（PLC 只读状态）
位/寄存器 (^) 名称 含义（V3 确认）

217 故障^ 1=系统故障（急停/水压/电机等），0=无故障^
240 就绪^ 1=允许启动（车到位/安全门禁通过），0=不允许^
214 运行态^ 1=正在执行洗车程序，0=空闲^
102 运行阶段 具体阶段值（0=空闲，1=泡沫，2=刷洗...）^
752 完成标志 1=完整洗车流程结束（厂商：仅完整结束时变^1 ，强制终止不变^1 ）^
MODE 启动请求^ 写^1 脉冲启动，PLC 自动清零，洗车中写入被忽略^
M60 强制终止^ 写^1 脉冲，PLC 立即终止程序^
M71 暂停/继续^ 写^1 脉冲切换暂停状态^
3.2 APP 流程状态（WashFlowState）
状态 说明
关键 PLC
条件
APP 动作（设备层调
用）
下一步迁移
Idle
首页，
轮询快
照
plc.read_all()^
点击开始 →
Selecting
Selecting
选择套
餐/附加
服务
仅需
217=
即可继续
plc.read_217()
确认 →
PaymentSelecting
PaymentSelecting
选择支
付方式
仅需
217=
无设备调用
选卡 → Paying_Card
选现金 →
Paying_Cash
Paying_Card
POS 支
付中
过程中若
217=1 →
失败
pos.start_payment()
pos.poll_transactio
n()
成功 →
PaymentAuthorized
失败 →
PaymentSelecting
Paying_Cash
现金收
款/找零 同上^
cash.enableAcceptor
(true)
cash.getAllLevels()
cash.collect()
cash.dispenseChange
()
成功 →
PaymentAuthorized
失败 →
Manual/Failed
PaymentAuthorized
支付成
功，等
待进入
GateCh
eck
无
固化交易 ID，准备
GateCheck
→
GateCheck_Wait
状态 说明
关键 PLC
条件
APP 动作（设备层调
用）
下一步迁移
GateCheck_Fault
故障阻
断
217=
plc.read_217()（只
读不复位）
217=0 →
GateCheck_Wait
GateCheck_Wait
等待
PLC 就
绪
240=
plc.read_240() 策略
轮询
240=1 →
Start_SendingMode
超时 →
Refunding/Manual
GateCheck_Wait
可选等
待点
（默认
关闭，
需现场
确认启
用）
752=
（启用时
条件）
plc.read_752() 策略
轮询
满足条件 →
GateCheck_Wait
或 Start
Start_SendingMode
发送启
动请求
必须：
217=
且
240=
plc.write_mode(1)
（脉冲）
写完 →
Start_Wait
Start_Wait
等待
PLC 进
入运行
态
214=0 →
等待
plc.read_214() 策略
轮询
214=1 →
Running_Wait102End
超时 →
Refunding/Manual
Running_Wait102En
d
运行监
控
214=
或 102≠
空闲
plc.read_102/214()
plc.write_m60/m71()
（用户触发）
102 结束 或 214=
→ Completed
取消(M60) →
TimeoutHandling →
Refunding
Completed
服务正
常完成
结束态
（214=0/
清理交易状态，生成
完成记录，
printer.print_recei
pt()（可选）
→ Idle
状态 说明
关键 PLC
条件
APP 动作（设备层调
用）
下一步迁移
102 空
闲）
TimeoutHandling
超时处
理（按
等待阶
段）
提示/延长/转退款^
执行策略后 →
Refunding 或 Retry
Refunding 退款中 -
pos.refund()
cash.dispenseChange
()（现金退回）
成功 → Refunded
需人工 →
ManualInterventionR
equired
Refunded
退款完
成 -
清理状态，
printer.print_refun
d_slip()（可选）
→ Idle
ManualIntervention
Required
人工介
入
-
展示原因/金额/指
引，不自动执行设备
操作
人工处理后 → Idle
Failed
失败页
（非退
款）
多语言错误提示^
→ Idle 或
PaymentSelecting
3.3 订单状态（OrderState）
独立于 WashFlowState，反映订单在交易维度的生命周期：
订单状态 含义 触发时机
ORDER_PAYMENT_INIT 订单创建，待支付 用户点击开始，生成订单
ORDER_PAID 已支付 支付成功（PaymentAuthorized）^
ORDER_SERVICE 服务中（已启动或正在等待启动）^ 进入 GateCheck 或 Start_SendingMode 后
ORDER_COMPLETED 服务完成^ Completed 状态到达^
ORDER_REFUNDING 退款中^ 进入 Refunding 状态^
ORDER_REFUNDED 已退款 Refunded 状态到达^
ORDER_MANUAL 需人工处理 ManualInterventionRequired 状态到达^
ORDER_CLOSED 订单关闭（终态）^ 所有终态均可映射到 CLOSED（历史记录）
映射关系：
 ORDER_COMPLETED = 正常服务完成
 ORDER_REFUNDED = 退款成功
 ORDER_MANUAL = 需人工介入（运营跟进）
 订单一旦进入上述终态，不再允许任何操作，如点击取消支付，或返回首页等
4. 状态迁移与订单生命周期映射
4.1 支付至 GateCheck 阶段
Idle → Selecting → PaymentSelecting → Paying_Card/Paying_Cash → PaymentAuthorized
订单状态变化：ORDER_PAYMENT_INIT → ORDER_PAID
 支付成功必须经过 PaymentAuthorized 状态，不得跳过。
 支付过程中若设备故障（如 POS 离线、纸币器卡钞），状态管理层根据错误类型引导重试
或进入 ManualInterventionRequired。
4.2 GateCheck 与启动阶段
PaymentAuthorized → GateCheck_Wait240 (或 GateCheck_Fault217) → Start_SendingMode → Star
t_Wait
订单状态：保持 ORDER_PAID → 进入 Start_SendingMode 后改为 ORDER_SERVICE
 硬门禁条件：217=0 且 240=
 启动指令：plc.write_mode(1) 脉冲，APP 不等待写完成，直接进入 Start_Wait214 开始
轮询 214 。
 写 MODE 失败处理：若写操作异常（网络/PLC 无响应），应重试有限次数（如 3 次），
否则进入 ManualInterventionRequired。
 防呆：若当前已在 Start_Wait214 或 Running 状态，禁止再次执行写 MODE。
4.3 运行监控与完成阶段
Start_Wait214 → Running_Wait102End → Completed
订单状态：ORDER_SERVICE → ORDER_COMPLETED
 轮询 214 和 102 ：
o 214=1 或 102≠空闲 → 进入 Running_Wait102End
o 214=0 且 102=空闲 → 洗车结束 → Completed
 M60（强制终止）：用户触发时 APP 调用 plc.write_m60(1)，PLC 终止程序。
o 收到 M60 后，APP 等待 PLC 状态稳定（214=0），然后进入 TimeoutHandling →
根据已服务时长/金额策略决定部分退款或视为完成。
 M71（暂停/继续）：用户触发时 APP 调用 plc.write_m71(1)，PLC 切换暂停状态，
APP 轮询不受影响，仅界面展示暂停提示。
4.4 异常处理策略（V3.2 强化设备状态异常处理）
异常场景 处理行为 订单终态
GateCheck_Wait240 超
时
策略化 soft/hard timeout，hard timeout 后进入
Refunding
ORDER_REFUNDED
Start_Wait214 超时 策略化超时，PLC 未进入运行态 → 退款 (^) ORDER_REFUNDED

运行中 217=1（故障）
启动故障等待计时，若 short timeout 内恢复
（217=0）则继续运行；否则进入
ManualInterventionRequired
ORDER_MANUAL
运行中超时（运行时间
超最大限制）
按策略可延长或终止 → 退款 (^) ORDER_REFUNDED

强制终止 M60 判断已服务比例，按策略决定部分退款或视为完成 ORDER_COMPLETED /
ORDER_REFUNDED
POS 支付失败
返回 PaymentSelecting，订单仍为
ORDER_PAYMENT_INIT
-
POS 退款失败 记录失败原因，进入 ManualInterventionRequired ORDER_MANUAL
现金设备 GetAllLevels
超时
状态管理层记录失败次数，按策略重试；连续失败超
阈值 → 硬超时退款，禁用现金支付入口 ORDER_REFUNDED
现金设备
GetDeviceStatus 连续
失败
状态管理层判定设备离线，立即禁用现金支付入口，
引导用户使用其他支付方式；已有支付会话进入
ManualInterventionRequired
ORDER_MANUAL
现金找零失败（缺零
钱）
提示用户可选其他支付方式或人工退款，进入
ManualInterventionRequired
ORDER_MANUAL
纸币器卡钞
禁用接收，提示人工，进入
ManualInterventionRequired
ORDER_MANUAL
打印机故障 记录错误，订单继续，后台记录待补打标记 不影响终态
关键规则：
 所有超时值必须可配置（按 MODEL1–4 分别设置），严禁硬编码。
 运行中故障恢复：PLC 在故障恢复后若仍在运行态（214=1），则 APP 继续监控，不重新
发送 MODE。
 禁止自动重发启动：任何情况下，APP 不得在未收到人工确认或订单重置的情况下自动写
MODE。
 支付设备错误：状态管理层必须捕获设备层抛出的所有异常，并根据错误码映射到用户友好
的提示语。
 严禁设备层自动重连：所有重连决策必须由状态管理层在用户明确操作或系统启动阶段进
行。
5. 订单终态规则（唯一合法终态）
订单只能以下列三种状态之一结束：
1. ORDER_COMPLETED
o 触发条件：Completed 状态到达（PLC 214=0 且 102=空闲）
o 含义：服务已完整执行，资金可结算，可打印完成小票。
2. ORDER_REFUNDED
o 触发条件：Refunded 状态到达（退款成功）
o 含义：已全额或部分退款，订单终止。
3. ORDER_MANUAL
o 触发条件：ManualInterventionRequired 状态到达
o 含义：系统无法自动完成，需人工介入处理，处理后人工关闭订单。
禁止状态：
 不允许订单处于“支付成功但未启动且未退款”的永久挂起状态。
 所有超时或失败路径必须导向上述三种终态之一。
6. 新订单准入规则（与订单状态解耦）
核心原则：
 新订单能否开始，由设备物理状态决定，不由历史订单状态决定。
 准入条件 = PLC 无故障（217=0）且 就绪（240=1）（即 GateCheck 通过条件）。
实现方式：
 APP 首页轮询 PLC 状态，只有当 217=0 && 240=1 时，开始按钮 才可点击。
 即使上一个订单异常结束（ORDER_MANUAL），只要设备满足条件，新订单即可开始。
 若设备不满足条件（如车未开走、故障中），开始按钮置灰，并展示具体原因。
支付设备状态检查（V3.2 新增）：
 APP 首页需显示现金设备健康状态（在线/离线/故障）。
 若所有支付方式均不可用（如现金设备离线且 POS 离线），开始按钮置灰并提示“当前无可
用支付方式”。
 现金设备状态由独立的 DeviceStatusMonitor 每 500ms 轮询 GetDeviceStatus 更新。
7. 不可违反的硬规则（V3.2 红线）
1. 支付后必须经过 GateCheck 才能启动
 严禁支付成功直接写 MODE。
2. 发送 MODE ≠ 订单完成
 订单终态必须等待服务真实结束或明确终止。
3. 禁止自动重新发送启动请求
 任何情况下，APP 不得自动重试写 MODE。
4. M60/M71 仅允许由用户主动触发
 APP 不可自动调用强制终止。
5. 752 不作为唯一门禁依据
 默认关闭 GateCheck_Wait752，除非现场反复验证后明确启用，且必须配合 240 共
同判断。
6. 所有等待点必须策略化超时
 不得使用固定超时值。
7. 订单状态机与设备状态机必须分离
 禁止用订单状态直接控制设备准入。
8. 设备层驱动必须实现接口，禁止业务逻辑直接操作硬件
 状态管理层只能通过注入的接口调用设备层，严禁在状态机代码中出现串口读写、协
议解析等。
9. 所有硬件驱动必须提供模拟实现
 单元测试及脱机演示环境必须依赖模拟驱动，不可依赖真实硬件。
10. 现金设备连接必须保持长连接，严禁在支付会话中重连
 OpenConnection 仅在 APP 启动时调用一次，支付过程中不得因任何错误触发重
连。
 设备状态通过 GetDeviceStatus 轮询监测，轮询间隔 350ms – 500ms。
11. 禁止设备层自动重连
 设备层驱动不得包含任何自动重试、自动恢复逻辑。
 重连决策仅允许由状态管理层在用户明确操作或系统启动时发起。
8. 策略化等待与超时配置（示例）
所有等待点超时参数均需从配置中心获取，按 MODEL1–4 及 支付方式 可独立设置。
等待点
软超时 (soft
timeout)
软超时动作
硬超时
(hard
timeout)
硬超时动作
GateCheck_Wait240 30s
提示“正在
准备洗车环
境...”
120s 进入 Refunding
Start_Wait214 10s
提示“正在
启动洗
车...”
30s 进入 Refunding
Running_Wait102End
MODEL 基准
时间 + 5min
提示“即将
完成”
基准时间 +
15min
超时终止 → 退款判
断
Paying_Cash（投币超
时）
60s
提示“请投
币”
180s
取消支付 →
PaymentSelecting
Paying_Cash（轮询超
时）
5s（连续 3
次）
重试
30s（连续 6
次）
退款 + 禁用现金支
付入口
Paying_Card（交易超
时）
30s
提示“刷卡
中...”
60s
失败 →
PaymentSelecting
POS 轮询交易结果
2s 轮询，持
续 30s
30s 无结果^
失败 →
PaymentSelecting
现金设备状态轮询 (^) 500ms

更新设备在
线标志
连续 3 次失
败
禁用现金支付入口
配置方式：
 所有超时参数存放于云端配置中心，APP 启动时拉取，支持热更新。
 本地需保留默认值，供首次启动或网络不可用时使用。
9. 附录：状态机对照表（V3.2 完整版）
状态
说
明
设备
条件
APP 动作（设备层调
用）
订单状态
超
时
策
略
Idle
首 页 ， 轮 询 快 照
-
plc.read_all()
cash.getDeviceStatus(
)（独立定时任务）
Selecting
选
择
套
餐
217
=
plc.read_217() ORDER_PAYMENT
_INIT
-
PaymentSelecting
选 择 支 付 方 式
217
=
-
ORDER_PAYMENT
_INIT
-
Paying_Card
PO
S
支
付
217
=
pos.start_payment()
pos.poll_transaction(
)
ORDER_PAYMENT
_INIT
交
易
超
时
Paying_Cash
现
金
收
款
217
=
cash.enableAcceptor(t
rue)
cash.getAllLevels()
ORDER_PAYMENT
_INIT
投
币
超
时
状态
说
明
设备
条件
APP 动作（设备层调
用）
订单状态
超
时
策
略
cash.collect()
cash.dispenseChange()
、
轮
询
超
时
PaymentAuthorized
支 付 成 功 ， 待 门 禁
ORDER_PAID -
GateCheck_Fault
故
障
阻
断
217
=
plc.read_217() (^) ORDER_PAID

等 待 故 障 恢 复
GateCheck_Wait
等
待
PL
C
就
绪
240
=
plc.read_240() 策略轮
询
ORDER_PAID
240
超
时
→
退
款
Start_SendingMode
发 送 启 动 请 求
217
=0 &
240
=
plc.write_mode(1) (^) ORDER_SERVICE -

状态
说
明
设备
条件
APP 动作（设备层调
用）
订单状态
超
时
策
略
Start_Wait
等 待 进 入 运 行 态
214
=
plc.read_214() 策略轮
询
ORDER_SERVICE
214
超
时
→
退
款
Running_Wait102End
运
行
监
控
214
=
或
102
≠
plc.read_102/214()
plc.write_m60/m71() ORDER_SERVICE
运 行 超 时 → 退 款
Completed
服
务
完
成
214
=0 &
102
=
printer.print_receipt
()（可选）
ORDER_COMPLET
ED
-
TimeoutHandling
超
时
处
理
提示/延长/转退款^
ORDER_PAID/SER
VICE
各 等 待 点 单 独
Refunding
退
款
中
-
pos.refund()
cash.dispenseChange()
ORDER_REFUNDI
NG
-
Refunded
退
款
完
成
-
printer.print_refund_
slip()（可选）
ORDER_REFUNDE
D
-
状态
说
明
设备
条件
APP 动作（设备层调
用）
订单状态
超
时
策
略
ManualInterventionRe
quired
人
工
介
入
展示原因，无设备操作 ORDER_MANUAL -
Failed
失
败
页
多语言提示^ - -
附录 A（Android/Kotlin 版）：现金设备层接口定义规范
根据 V3.2 规范的核心要求——设备层严禁包含任何业务重连逻辑、仅负责指令收发与状态上报，
以下提供完整的 Android (Kotlin + Coroutines) 实现范例。所有代码均遵循 单一职责原则，并与
规范中的 连接生命周期管理、状态监测独立轮询 严格对齐。
A.1 现金设备统一接口（Kotlin）
/**

现金设备（纸币器/硬币器）统一接口
所有具体设备驱动必须实现此接口
方法均为挂起函数，便于在协程中调用
*/
interface CashDevice {
/**

建立与设备的通信连接
仅允许在 APP 启动时调用一次，支付会话中严禁调用
@param port 串口号（0,1...）
@param sspAddress SSP 地址（纸币器通常为 0 ，硬币器通常为 16 ）
@return true 表示连接成功
*/
suspend fun openConnection(port: Int, sspAddress: Int): Boolean
/**

获取设备实时健康状态
必须由独立的状态监测任务以 350~500ms 间隔轮询
*/
suspend fun getDeviceStatus(): DeviceStatus

/**

启用/禁用纸币/硬币接收器
@param enable true = 允许接收，false = 禁止接收
*/
suspend fun enableAcceptor(enable: Boolean): Boolean
/**

获取当前所有面额的库存快照（用于计算收款金额）
单位：分（cents）
*/
suspend fun getAllLevels(): List
/**

执行收款（将 escrow 中的现金存入钱箱）
通常在用户确认支付后调用
*/
suspend fun collect(): Boolean
/**

执行找零
@param amountCents 需找零金额（分）
@return 找零结果（成功/失败/找零不足等）
*/
suspend fun dispenseChange(amountCents: Int): DispenseResult
/**

查询当前找零能力（缺零钱、面额可用性等）
*/
suspend fun getChangeStatus(): ChangeStatus
/**

设备是否在线（根据最近一次 getDeviceStatus 结果缓存）
该属性为只读，由驱动内部维护，状态管理层可直接读取
*/
val isOnline: Boolean
}
相关数据类定义
data class DeviceStatus(

val online: Boolean, // true = 设备响应正常
val errorCode: Int = 0 , // 0 表示无错误
val errorMessage: String? = null

)

data class Denomination(

val countryCode: String, // 货币代码，如 "EUR"
val value: Int, // 面额（分）
val stored: Int // 当前库存数量
)

sealed class DispenseResult {
object Success : DispenseResult()
data class InsufficientChange(val missingAmount: Int) : DispenseResult()
data class HardwareError(val reason: String) : DispenseResult()
}

data class ChangeStatus(

val canMakeChange: Boolean, // 是否能够找零
val availableDenominations: List, // 可找零面额列表（分）
val shortageAmount: Int = 0 // 如果找零不足，缺少的金额（分）
)

A.2 具体设备实现示例（纸币器）
kotlin
/**

SPECTRAL_PAYOUT 纸币器驱动实现
完全遵循设备层职责：仅收发指令，不包含任何重试、重连、业务决策
*/
class SpectralPayoutDevice @Inject constructor(
private val api: CashDeviceApi, // Retrofit 接口
private val deviceId: String = "SPECTRAL_PAYOUT-0"
) : CashDevice {

// 设备连接是否已建立（仅用于标记，不代表当前物理状态）
private var _isConnected = false

// 最近一次 GetDeviceStatus 的结果缓存
@Volatile
private var _lastStatus = DeviceStatus(online = false, errorCode = - 1 )

override val isOnline: Boolean
get() = _lastStatus.online

override suspend fun openConnection(port: Int, sspAddress: Int): Boolean {
return try {

val response = api.openConnection(
OpenConnectionRequest(
comPort = port,
sspAddress = sspAddress,

enableAcceptor = false, // 连接时默认不启用接收
enablePayout = true // 允许找零
)
)
_isConnected = response.isOpen

// 连接成功后立即进行一次状态查询以初始化 _lastStatus
_lastStatus = getDeviceStatus()
_isConnected
} catch (e: Exception) {

// 仅将异常转换为状态，不进行任何重试
_lastStatus = DeviceStatus(online = false, errorCode = - 1 )
false
}
}

override suspend fun getDeviceStatus(): DeviceStatus {
return try {

// 假设 API 提供了获取设备状态的接口
val status = api.getDeviceStatus(deviceId)
DeviceStatus(online = true, errorCode = 0 ).also {
_lastStatus = it
}
} catch (e: Exception) {
DeviceStatus(online = false, errorCode = - 1 ).also {
_lastStatus = it
}
}
}

override suspend fun enableAcceptor(enable: Boolean): Boolean {
return try {
if (enable) {
api.enableAcceptor(deviceId).isSuccessful
} else {
api.disableAcceptor(deviceId).isSuccessful
}
} catch (e: Exception) {
false
}
}

override suspend fun getAllLevels(): List {
return try {

val response = api.getAllLevels(deviceId)
response.levels.map {
Denomination(it.countryCode, it.value, it.stored)
}
} catch (e: Exception) {

// 仅抛出异常，由状态管理层处理
throw CashDeviceException("GetAllLevels failed", e)
}
}

override suspend fun collect(): Boolean {
return try {
api.collect(deviceId).isSuccessful
} catch (e: Exception) {
false
}
}

override suspend fun dispenseChange(amountCents: Int): DispenseResult {
return try {
val result = api.dispenseValue(deviceId, amountCents)
if (result.isSuccessful) {

// 根据业务逻辑解析结果
DispenseResult.Success
} else {
DispenseResult.HardwareError(result.errorBody()?.string() ?: "Unknown error")
}
} catch (e: Exception) {
DispenseResult.HardwareError(e.message ?: "Network error")
}
}

override suspend fun getChangeStatus(): ChangeStatus {
return try {
val levels = getAllLevels()
val available = levels.filter { it.stored > 0 }.map { it.value }
ChangeStatus(
canMakeChange = available.isNotEmpty(),
availableDenominations = available
)
} catch (e: Exception) {
ChangeStatus(false, emptyList())
}
}
}

关键点说明
1. 无自动重连
openConnection 仅在外部主动调用时执行，驱动内部没有任何因超时或错误而自动调用的
逻辑。
2. 状态缓存
_lastStatus 由 getDeviceStatus() 更新，isOnline 属性直接返回此缓存，供状态管理
层快速读取。
3. 异常传播
getAllLevels 等关键业务方法直接抛出异常，绝不捕获后静默处理，确保状态管理层能够
感知并执行超时策略。
A.3 模拟实现（单元测试/脱机演示）
/**

纸币器模拟实现
可用于单元测试、UI 脱机演示
*/
class MockBillAcceptor : CashDevice {
private var _online = true
private var _acceptorEnabled = false
private var _levels = mutableMapOf(

500 to 1 , // 1 张 5€
1000 to 0 ,

2000 to 2 , // 2 张 20€
5000 to 0 ,
10000 to 0 ,
20000 to 0 ,
50000 to 0
)

override val isOnline: Boolean
get() = _online

override suspend fun openConnection(port: Int, sspAddress: Int): Boolean {
_online = true
return true
}

override suspend fun getDeviceStatus(): DeviceStatus {
return DeviceStatus(online = _online, errorCode = 0 )
}

override suspend fun enableAcceptor(enable: Boolean): Boolean {
_acceptorEnabled = enable
return true
}

override suspend fun getAllLevels(): List {
return _levels.map { (value, stored) ->
Denomination("EUR", value, stored)
}
}

override suspend fun collect(): Boolean {

// 模拟收款：将当前 escrow 中的金额转入钱箱（本例简化）
return true
}

override suspend fun dispenseChange(amountCents: Int): DispenseResult {

// 模拟找零：简单检查是否有足够库存
val totalAvailable = _levels.filterKeys { it <= 2000 }.values.sum()
return if (totalAvailable >= amountCents) {

// 扣减库存（简化）
DispenseResult.Success
} else {
DispenseResult.InsufficientChange(amountCents - totalAvailable)
}
}

override suspend fun getChangeStatus(): ChangeStatus {
val available = _levels.filter { it.value > 0 && it.key <= 2000 }.keys.toList()
return ChangeStatus(
canMakeChange = available.isNotEmpty(),
availableDenominations = available
)
}

fun setOffline() { _online = false }
fun addNote(value: Int) { _levels[value] = _levels.getOrDefault(value, 0 ) + 1 }
}

A.4 状态管理层如何使用设备驱动
1. 依赖注入（Hilt 示例）
/**

纸币器模拟实现
可用于单元测试、UI 脱机演示
*/
class MockBillAcceptor : CashDevice {
private var _online = true
private var _acceptorEnabled = false
private var _levels = mutableMapOf(

500 to 1 , // 1 张 5€
1000 to 0 ,

2000 to 2 , // 2 张 20€
5000 to 0 ,
10000 to 0 ,
20000 to 0 ,
50000 to 0
)

override val isOnline: Boolean
get() = _online

override suspend fun openConnection(port: Int, sspAddress: Int): Boolean {
_online = true
return true
}

override suspend fun getDeviceStatus(): DeviceStatus {
return DeviceStatus(online = _online, errorCode = 0 )
}

override suspend fun enableAcceptor(enable: Boolean): Boolean {
_acceptorEnabled = enable
return true
}

override suspend fun getAllLevels(): List {
return _levels.map { (value, stored) ->
Denomination("EUR", value, stored)
}
}

override suspend fun collect(): Boolean {

// 模拟收款：将当前 escrow 中的金额转入钱箱（本例简化）
return true
}

override suspend fun dispenseChange(amountCents: Int): DispenseResult {

// 模拟找零：简单检查是否有足够库存
val totalAvailable = _levels.filterKeys { it <= 2000 }.values.sum()
return if (totalAvailable >= amountCents) {

// 扣减库存（简化）
DispenseResult.Success
} else {
DispenseResult.InsufficientChange(amountCents - totalAvailable)
}
}

override suspend fun getChangeStatus(): ChangeStatus {
val available = _levels.filter { it.value > 0 && it.key <= 2000 }.keys.toList()
return ChangeStatus(
canMakeChange = available.isNotEmpty(),
availableDenominations = available
)
}

fun setOffline() { _online = false }
fun addNote(value: Int) { _levels[value] = _levels.getOrDefault(value, 0 ) + 1 }
}

A.4 状态管理层如何使用设备驱动
1. 依赖注入（Hilt 示例）
@Module
@InstallIn(SingletonComponent::class)
object CashDeviceModule {

@Provides
@Singleton
fun provideBillAcceptor(
@CashDeviceApi retrofit: Retrofit
): CashDevice {
val api = retrofit.create(CashDeviceApi::class.java)

return SpectralPayoutDevice(api) // 生产环境
// return MockBillAcceptor() // 脱机调试
}

@Provides
@Singleton
fun provideCoinAcceptor(

@CashDeviceApi retrofit: Retrofit
): CashDevice {
val api = retrofit.create(CashDeviceApi::class.java)

return SmartCoinSystemDevice(api) // 硬币器实现（略）
}
}

2. 设备状态独立监测服务
@Singleton
class CashDeviceStatusMonitor @Inject constructor(
private val billAcceptor: CashDevice,
private val coinAcceptor: CashDevice,
private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {
private val _billOnline = MutableStateFlow(true)
val billOnline: StateFlow = _billOnline.asStateFlow()

private val _coinOnline = MutableStateFlow(true)
val coinOnline: StateFlow = _coinOnline.asStateFlow()

private var monitorJob: Job? = null

fun startMonitoring(scope: CoroutineScope) {
monitorJob = scope.launch(dispatcher) {
while (isActive) {
updateDeviceStatus()

delay( 500 ) // 500ms 间隔，符合厂商建议
}
}
}

private suspend fun updateDeviceStatus() {
_billOnline.value = try {
val status = billAcceptor.getDeviceStatus()
status.online
} catch (e: Exception) {
false
}

_coinOnline.value = try {
val status = coinAcceptor.getDeviceStatus()
status.online
} catch (e: Exception) {
false
}

// 当任一设备连续离线超过阈值时，由状态管理层决策是否禁用现金支付
// 此处仅更新状态，不包含任何重连逻辑
}

fun stopMonitoring() {
monitorJob?.cancel()
monitorJob = null
}
}

3. 支付流程中的轮询与超时处理
class PaymentViewModel @Inject constructor(

private val cashDevice: CashDevice, // 实际上可能需要分别注入纸币器和硬币器
private val statusMonitor: CashDeviceStatusMonitor
) : ViewModel() {

private var pollingJob: Job? = null

fun startCashPayment(targetAmountCents: Int) {
viewModelScope.launch {

// 1. 启用接收器（不重连，仅发送指令）
cashDevice.enableAcceptor(true)

// 2. 轮询收款
var consecutiveFailures = 0
pollingJob = launch {
while (isActive) {
try {
val levels = cashDevice.getAllLevels()
consecutiveFailures = 0
val paid = calculateDelta(levels)
if (paid >= targetAmountCents) {
onPaymentSuccess(paid)
break
}
} catch (e: Exception) {
consecutiveFailures++
if (consecutiveFailures >= MAX_POLLING_FAILURES) {
onPaymentTimeout()
break
}
}
delay(POLLING_INTERVAL)
}

}.also { pollingJob = it }
}
}

private fun onPaymentSuccess(paid: Int) {

// 禁用接收器
viewModelScope.launch {
cashDevice.enableAcceptor(false)

cashDevice.collect() // 收款入箱
}

// 更新状态机，跳转至 PaymentAuthorized
}

private fun onPaymentTimeout() {
viewModelScope.launch {
cashDevice.enableAcceptor(false)
}

// 触发退款流程
}
}

A.5 与 V3.2 规范的一致性检查
规范要求 当前实现
设备层不含任何重试、重连逻辑 ✅^ 所有驱动方法仅执行单次请求，异常直接抛出或返回失败，无重试循环
连接仅建立一次 ✅^ openConnection^ 仅在 APP 启动时由^ CashDeviceManager^ 调用一次^
状态监测独立轮询 ✅^ CashDeviceStatusMonitor^ 以 500ms 间隔调用^ getDeviceStatus^
支付轮询超时由状态管理层控制 ✅^ PaymentViewModel^ 捕获异常并计数，超过阈值后主动终止支付^
设备状态缓存 ✅^ 驱动内部维护^ _lastStatus^ 并暴露^ isOnline^ 属性^
模拟实现 ✅^ MockBillAcceptor^ 完整实现接口，支持脱机测试^
以上代码示例可直接集成至基于 Android Studio / Kotlin + Coroutines 的项目中，严格
遵循 V3.2 规范关于设备层的所有约束。
开发团队应参照此范式重构 CashDeviceRepository 及相关驱动，彻底移除支付过程中
的自动重连逻辑。
This is a offline tool, your data stays locally and is not send to any server!
Feedback & Bug Reports