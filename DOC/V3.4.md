**洗车支付系统技术规范 V3.4（修订版）**

**1. 概述与核心原则**

`	`本规范基于厂商最终确认的 PLC 行为、支付外设硬件特性及实际运营边界，明确定义 APP 状态机、订单生命周期、设备控制职责与硬件抽象分层。以下三条核心原则不可违反：

**1.1 状态机驱动**

- UI 仅根据 WashFlowState 渲染，绝不直接猜测或依赖设备瞬态值。
- 任何设备事件（PLC 位变化、POS 交易结果、现金接收、打印机状态）必须通过事件/用例推动状态迁移，禁止在 UI 层或订单层直接修改状态。

**1.2 异步监控，非主动控制（洗车机）**

- APP 不“控制”洗车过程，只负责发送启动请求和监控运行状态。
- 启动指令为写 MODE 寄存器（脉冲），PLC 自动清零，APP 禁止重复发送或回写 0。
- 运行中 APP 不干预 PLC 内部逻辑，仅监听 214/102/217 等状态位。

**1.3 订单终态定义**

- **发送 MODE 成功后，订单进入待确认状态（ORDER\_PENDING\_CONFIRMATION）**；若后续检测到 PLC 进入运行态（214=1 或 102≠0），则订单自动变为已完成（ORDER\_COMPLETED）；若在规定超时内未检测到运行态，订单转为人工处理状态（ORDER\_MANUAL），需人工介入。订单终态（COMPLETED / REFUNDED / MANUAL）一旦确定，不可变更。

**2. 系统架构分层**

系统分为四个逻辑层次，下层为上层提供标准化服务，严禁跨层调用。

**2.1 层次定义**

|层次|职责|关键组件|
| :- | :- | :- |
|设备层|与所有物理硬件直接交互，读取状态、发送指令，仅暴露标准化接口给上层|PLC驱动、现金驱动、POS驱动、打印机驱动等|
|状态管理层|维护APP流程状态 WashFlowState，轮询设备，执行超时策略，决策状态迁移|状态机引擎、轮询服务、计时器|
|订单层|维护订单生命周期 OrderState，关联支付交易、退款、财务记录|订单服务、支付网关代理|
|UI层|仅根据 WashFlowState 渲染界面，无任何业务逻辑||
**2.2 设备层详细构成**

`	`所有物理硬件驱动均位于 device/ 目录，按设备类别拆分模块，每个模块只负责本类硬件的指令收发与状态上报，不包含任何业务流程逻辑。

**2.2.1 设备驱动模块结构**

text

DeviceLayer/

├── plc\_driver/               # 洗车机 PLC

│   ├── plc\_client.py         # TCP/Modbus 通信封装

│   ├── registers.py          # 寄存器地址定义（217/240/214/102/752/MODE/M60/M71）

│   └── plc\_interface.py      # 读状态、写MODE、M60/M71

├── cash\_device/              # 现金支付设备（纸币器+硬币器）

│   ├── driver/               # 底层通信协议（SSP等）

│   ├── device\_manager.py     # 连接生命周期管理（单例，全局唯一）

│   ├── bill\_acceptor.py      # 纸币器专用接口（继承自CashDeviceBase）

│   ├── coin\_acceptor.py      # 硬币器专用接口（继承自CashDeviceBase）

│   └── cash\_interface.py     # 暴露给状态管理层的统一接口（含状态监测、收款、找零）

├── pos\_terminal/             # POS终端

│   ├── pos\_serial.py         # 串口/以太网通信

│   ├── pos\_protocol.py       # 交易/撤销/退款/查询指令

│   └── pos\_interface.py      # 支付、退款、结果回调、小票打印

├── printer/                  # 热敏打印机

│   └── printer\_driver.py     # 打印小票/二维码/故障检测

└── voice/                    # 语音播报（可选）

`    `└── voice\_player.py       # 播放提示音、语音合成

**关键说明**：

- **纸币器/硬币器连接生命周期管理**：APP 启动时，由 CashDeviceManager 负责调用一次 OpenConnection 与所有已识别设备建立通信会话。连接成功后永久保持，**不得在支付流程中关闭或重新打开连接**。初始状态下，接收器处于禁用状态（调用 EnableAcceptor(false)），仅在进入 Paying\_Cash 状态时才启用接收。
- **状态监测**：独立定时任务（间隔 500ms）调用 GetDeviceStatus 更新设备健康状态，驱动层缓存最新状态，供状态管理层查询。

**2.2.2 现金支付模块详细设计（基于事件驱动）**

`	`本文档为现金支付模块的完整实现指南，涵盖从收款开始到交易结束的全流程，包括动态找零控制、状态管理、失败恢复等关键环节。方案基于 ITL SDK REST API，采用事件驱动机制实时累加金额，并引入 **Change Guard（动态找零守卫）** 模块实现接收前风险控制。

**2.2.2.1 引言**

**目标**：

- 实现稳定、可靠的现金支付流程，支持纸币/硬币接收、动态找零能力评估、面额实时禁用/放行、找零执行及异常恢复。
- 确保交易一致性：已收金额准确、找零可行、状态可追溯。
- 提供清晰的模块划分，便于维护和扩展。

**整体架构**：\
系统由以下核心模块构成，职责分明：

|模块|职责|
| :- | :- |
|**Payment Session**|管理单次交易的生命周期，维护会话状态、已收金额、目标金额，协调其他模块。|
|**Inventory Provider**|通过 GetCurrencyAssignment 获取设备当前纸币/硬币库存（面额、数量）。|
|**Change Guard**|评估接收某面额后是否还能找零，输出应禁用的面额列表。|
|**Denomination Controller**|调用 SetDenominationInhibits 将禁用策略下发至设备。|
|**Payout Orchestrator**|执行找零（DispenseValue），监控找零结果。|
|**Failure Handler**|处理找零失败、卡币等异常，提供重试/退款/恢复机制。|

模块间通过事件或回调通信，整体流程如下（**注意：每次操作前应先确认设备状态正常**）：

graph TD

Start[进入Paying\_Cash] --> CheckStatus{GetDeviceStatus}

CheckStatus -- 状态正常(非故障状态) --> A[Payment Session]

CheckStatus -- 状态异常 --> FailureHandler

A -->|拉取库存| B[Inventory Provider]

A -->|评估策略| C[Change Guard]

C -->|禁用列表| D[Denomination Controller]

D -->|下发inhibit| E[ITL Device]

A -->|使能接收器| E

Note over A: 开始轮询 CashEventResponse

A -->|收到收款事件| A

A -->|达到目标| F[Payout Orchestrator]

F -->|找零| E

F -->|结果| G[Failure Handler]

G -->|恢复/重试| A

G -->|人工介入| Manual

**关键点**：

- 每次进行库存拉取、策略评估、指令下发前，均需通过独立状态监测确保设备在线且正常。
- 若设备状态异常，直接转入 FailureHandler，最终导向人工介入。
- 设备异常是指以下情况：
  - ERROR：设备严重错误
  - JAMMED：卡钞/卡币
  - FRAUD\_ATTEMPT：欺诈行为
  - CASHBOX\_REMOVED：钱箱被移除
  - NOTE\_HELD\_IN\_BEZEL：纸币卡在入币口
  - REJECTING：持续拒收
  - MAINTENANCE\_REQUIRED：需要维护
  - 连续通信失败导致设备离线

**2.2.2.2 系统模块设计**

**2.2.2.2.1 Payment Session（交易会话层）**

- **职责**：管理单次交易的状态、已收金额、目标金额；订阅 CashEventResponse 累加金额；触发其他模块工作。
- **关键属性**：

kotlin

var sessionId: String

var targetAmountCents: Long

var paidAmountCents: Long

var state: PaymentState

var changeNeeded: Long

- **核心方法**：
  - startSession(target: Long)：开始新会话，初始化状态，触发第一次策略评估。
  - handleCashEvent(event: CashEventResponse)：累加金额，触发策略刷新。
  - onPaymentComplete()：达到目标金额后，计算找零并调用 PayoutOrchestrator。
  - onPayoutResult(result: PayoutResult)：处理找零结果，更新状态。

**2.2.2.2.2 Inventory Provider（库存读取层）**

- **职责**：封装 GetCurrencyAssignment 调用，返回格式化的库存数据。
- **数据模型**：

kotlin

data class Denomination(

`    `val value: Long,               *// 面额（分）*

`    `val countryCode: String,        *// 货币代码*

`    `val stored: Int,                *// 库存数量*

`    `val isRecyclable: Boolean,      *// 是否可找零*

`    `val channel: Int                *// 通道号*

)

data class Inventory(

`    `val bills: List<Denomination>,  *// 纸币*

`    `val coins: List<Denomination>   *// 硬币*

)

- **方法**：
  - suspend fun fetchInventory(deviceId: String): Inventory

**2.2.2.2.3 Change Guard（动态找零守卫）**

- **职责**：根据当前库存、已收金额、目标金额，判断各面额是否应被禁用，确保接收后仍有足够零钱找零。
- **输入参数**：
  - target: Long 目标金额
  - paid: Long 已收金额
  - inventory: Inventory 当前库存
  - minChangeReserve: Long 最小找零保留金（配置项）
- **输出**：

kotlin

data class GuardResult(

`    `val unsafeDenoms: List<Denomination>, *// 应禁用的面额*

`    `val safeDenoms: List<Denomination>,   *// 可放行的面额*

`    `val reason: String                    *// 决策原因（日志用）*

)

- **核心算法**：
  - 对于**每种面额** d（无论面额大小）：
    - 假设接收该面额后，新已收金额 paid2 = paid + d.value。
    - 如果 paid2 < target，则无需找零，该面额**安全**。
    - 否则，需找零金额 need = paid2 - target。
    - 模拟扣除这张纸币/硬币后的库存（即该面额数量减1），检查剩余库存能否精确支付 need，且保留至少 minChangeReserve 零钱。
    - 若不能精确找零，则该面额**不安全**，加入禁用列表；否则**安全**。
  - 返回禁用列表 unsafeDenoms 和放行列表 safeDenoms。

**2.2.2.2.4 Denomination Controller（设备控制层）**

- **职责**：将 GuardResult.unsafeDenoms 转换为 SetDenominationInhibits 请求，禁用不安全面额；同时确保安全面额被放行（解除抑制）。
- **注意**：抑制设置应**幂等**，每次调用时都明确设置所有面额的状态，避免依赖历史。
- **方法**：
  - suspend fun applyInhibits(deviceId: String, unsafe: List<Denomination>)

**2.2.2.2.5 Payout Orchestrator（找零执行层）**

- **职责**：执行找零金额的支付（DispenseValue），监控找零过程，返回结果。
- **方法**：
  - suspend fun payout(deviceId: String, amount: Long, currency: String): PayoutResult
- **结果类型**：

kotlin

sealed class PayoutResult {

`    `object Success : PayoutResult()

`    `data class Failure(val reason: String, val errorCode: String?) : PayoutResult()

`    `data class Incomplete(val paidOut: Long) : PayoutResult() *// 部分找零*

}

- **实现**：调用 DispenseValue 后，通过轮询 GetDeviceStatus 监听 DispenserTransactionEventResponse 获取最终状态（COMPLETED / ERROR）。

**2.2.2.2.6 Failure Handler（异常闭环层）**

- **职责**：处理找零失败、卡币等异常，记录日志，与用户交互，尝试恢复。
- **方法**：
  - suspend fun handlePayoutFailure(session: PaymentSession, result: PayoutResult)
  - suspend fun handleJam(event: CashEventResponse, session: PaymentSession)
- 恢复流程：恢复流程：见2.2.2.7节

**2.2.2.3 状态机设计（支付会话）**

使用 sealed class 定义支付会话状态：

kotlin

sealed class PaymentState {

`    `object Idle : PaymentState()                     *// 无进行中交易*

`    `object SessionActive : PaymentState()            *// 已选商品，可接收现金*

`    `object Receiving : PaymentState()                *// 收款中（已投币）*

`    `object PaymentCompleting : PaymentState()        *// 达到金额，准备找零*

`    `object PayoutInProgress : PaymentState()         *// 找零执行中*

`    `object Completed : PaymentState()                 *// 交易成功*

`    `object Cancelled : PaymentState()                 *// 用户取消/超时*

`    `object PayoutFailed : PaymentState()              *// 找零失败*

`    `object RefundInProgress : PaymentState()          *// 退款中*

`    `object Recovered : PaymentState()                  *// 故障恢复后回到Idle*

}

**状态转换图**（简化）：

text

Idle -- startSession() --> SessionActive

SessionActive -- 收到第一笔钱 --> Receiving

Receiving -- 每次收钱后刷新策略 --> Receiving

Receiving -- paid >= target --> PaymentCompleting

PaymentCompleting -- 计算找零 --> PayoutInProgress

PayoutInProgress -- 找零成功 --> Completed

PayoutInProgress -- 找零失败 --> PayoutFailed

PayoutFailed -- 用户选择重试 --> PaymentCompleting

PayoutFailed -- 用户选择退款 --> RefundInProgress

RefundInProgress -- 退款成功 --> Cancelled/Recovered

PayoutFailed -- 用户取消 --> Cancelled

Cancelled/Completed -- reset() --> Idle

**2.2.2.4 核心业务流程**

**2.2.2.4.1 交易开始流程（SessionActive → Receiving）**

sequenceDiagram

`    `participant App

`    `participant PaymentSession

`    `participant InventoryProvider

`    `participant ChangeGuard

`    `participant DenomController

`    `participant Device

`    `App->>PaymentSession: startSession(target)

`    `PaymentSession->>InventoryProvider: fetchInventory()

`    `InventoryProvider-->>PaymentSession: inventory

`    `PaymentSession->>ChangeGuard: evaluate(target, 0, inventory)

`    `ChangeGuard-->>PaymentSession: unsafeDenoms, safeDenoms

`    `PaymentSession->>DenomController: applyInhibits(unsafeDenoms)

`    `DenomController->>Device: POST /SetDenominationInhibits

`    `Device-->>DenomController: 200 OK

`    `DenomController-->>PaymentSession: done

`    `PaymentSession->>Device: EnableAcceptor()

`    `PaymentSession->>PaymentSession: state = Receiving

**2.2.2.4.2 每次收款后的刷新流程（Receiving → Receiving）**

sequenceDiagram

`    `participant Device

`    `participant PaymentSession

`    `participant InventoryProvider

`    `participant ChangeGuard

`    `participant DenomController

`    `Device->>PaymentSession: CashEventResponse (STORED, value)

`    `PaymentSession->>PaymentSession: paidAmountCents += value

`    `PaymentSession->>InventoryProvider: fetchInventory()

`    `InventoryProvider-->>PaymentSession: inventory (updated)

`    `PaymentSession->>ChangeGuard: evaluate(target, paid, inventory)

`    `ChangeGuard-->>PaymentSession: unsafeDenoms, safeDenoms

`    `PaymentSession->>DenomController: applyInhibits(unsafeDenoms)

`    `DenomController-->>PaymentSession: done

`    `Note over PaymentSession: 等待下一张纸币/硬币

**2.2.2.4.3 交易完成与找零流程（PaymentCompleting → Completed/Failed）**

sequenceDiagram

`    `participant PaymentSession

`    `participant PayoutOrchestrator

`    `participant FailureHandler

`    `participant Device

`    `PaymentSession->>PaymentSession: 检测到 paid >= target

`    `PaymentSession->>PaymentSession: state = PaymentCompleting

`    `PaymentSession->>PaymentSession: changeNeeded = paid - target

`    `PaymentSession->>PayoutOrchestrator: payout(changeNeeded)

`    `PayoutOrchestrator->>Device: POST /DispenseValue

`    `Device-->>PayoutOrchestrator: 202 Accepted

`    `loop 轮询 GetDeviceStatus

`        `PayoutOrchestrator->>Device: GET /GetDeviceStatus

`        `Device-->>PayoutOrchestrator: DispenserTransactionEventResponse

`    `end

`    `alt 找零成功 (COMPLETED)

`        `PayoutOrchestrator-->>PaymentSession: PayoutResult.Success

`        `PaymentSession->>PaymentSession: state = Completed

`    `else 找零失败 (ERROR / INCOMPLETE)

`        `PayoutOrchestrator-->>PaymentSession: PayoutResult.Failure

`        `PaymentSession->>PaymentSession: state = PayoutFailed

`        `PaymentSession->>FailureHandler: handlePayoutFailure(session, result)

`    `end

**2.2.2.4.4 失败处理流程（PayoutFailed → 恢复/退款）**

sequenceDiagram

`    `participant FailureHandler

`    `participant UI

`    `participant PaymentSession

`    `participant PayoutOrchestrator

`    `FailureHandler->>UI: 显示"找零失败，请选择"

`    `UI-->>FailureHandler: 用户选择"重试"

`    `FailureHandler->>PaymentSession: retryPayout()

`    `PaymentSession->>PayoutOrchestrator: payout(changeNeeded)

`    `alt 重试成功

`        `PayoutOrchestrator-->>PaymentSession: Success

`        `PaymentSession->>PaymentSession: state = Completed

`    `else 重试失败达阈值

`        `FailureHandler->>UI: 建议退款

`        `UI-->>FailureHandler: 用户选择"退款"

`        `FailureHandler->>PaymentSession: refund()

`        `PaymentSession->>PayoutOrchestrator: payout(paidAmount) // 退还已收金额

`        `alt 退款成功

`            `PaymentSession->>PaymentSession: state = Cancelled

`        `else 退款失败

`            `FailureHandler->>UI: 人工干预告警

`        `end

`    `end

**2.2.2.5 关键算法实现**

**2.2.2.5.1 动态找零能力判定（DP算法）**

kotlin

fun canMakeChange(

`    `need: Long,                     *// 需要找零的金额（分）*

`    `denominations: List<Denomination> *// 可用的面额列表（含库存数量）*

): Boolean {

`    `if (need <= 0) return true

`    `val maxAmount = denominations.sumOf { it.value \* it.stored }

`    `if (need > maxAmount) return false

`    `*// 防止DP数组过大导致卡顿（商业保护）*

`    `val MAX\_DP\_AMOUNT = 5000L

`    `if (need > MAX\_DP\_AMOUNT) {

`        `return greedyApproximation(need, denominations)

`    `}

`    `val dp = BooleanArray(need.toInt() + 1)

`    `dp[0] = true

`    `for (denom in denominations) {

`        `val value = denom.value.toInt()

`        `var count = denom.stored

`        `*// 二进制拆分优化（多重背包优化）*

`        `var k = 1

`        `while (count > 0) {

`            `val use = minOf(k, count)

`            `val amount = use \* value

`            `for (x in need.toInt() downTo amount) {

`                `if (dp[x - amount]) dp[x] = true

`            `}

`            `count -= use

`            `k = k shl 1

`        `}

`    `}

`    `return dp[need.toInt()]

}

kotlin

fun canMakeChangeWithReserve(

`    `need: Long,

`    `inventory: Inventory,

`    `reserve: Long

): Boolean {

`    `require(reserve >= 0) { "reserve cannot be negative" }

`    `val totalAvailable =

`        `inventory.bills.sumOf { it.value \* it.stored } +

`        `inventory.coins.sumOf { it.value \* it.stored }

`    `val usable = totalAvailable - reserve

`    `if (usable < need) return false

`    `return canMakeChange(

`        `need,

`        `(inventory.bills + inventory.coins).filter { it.stored > 0 }

`    `)

}

**2.2.2.5.2 面额禁用策略实现**

kotlin

fun evaluateDenomination(

`    `d: Denomination,

`    `target: Long,

`    `paid: Long,

`    `inventory: Inventory,

`    `reserve: Long

): Boolean {

`    `val newPaid = paid + d.value

`    `if (newPaid < target) return true                     *// 还不需要找零，安全*

`    `val need = newPaid - target

`    `*// 模拟扣除这张纸币后的库存*

`    `val tempInventory = inventory.copy(

`        `bills = inventory.bills.map {

`            `if (it.channel == d.channel) it.copy(stored = it.stored - 1) else it

`        `}

`    `)

`    `return canMakeChangeWithReserve(need, tempInventory, reserve)

}

**2.2.2.6 代码实现示例（Kotlin / Android）**

**2.2.2.6.1 项目结构**

text

com.example.cashpayment/

├── api/                 # Retrofit接口定义

├── data/                # 数据模型

├── domain/              # 核心业务模块

│   ├── PaymentSession.kt

│   ├── InventoryProvider.kt

│   ├── ChangeGuard.kt

│   ├── DenominationController.kt

│   ├── PayoutOrchestrator.kt

│   └── FailureHandler.kt

├── ui/                  # Activity/ViewModel

└── utils/               # 工具类

**2.2.2.6.2 数据模型定义**

kotlin

*// api 响应模型（与ITL SDK一致）*

data class CurrencyAssignmentItem(

`    `val type: Int,

`    `val value: Long,

`    `val countryCode: String,

`    `val isInhibited: Boolean,

`    `val isRecyclable: Boolean,

`    `val stored: Int,

`    `val channel: Int

)

*// 业务模型*

data class Denomination(

`    `val value: Long,

`    `val countryCode: String,

`    `val stored: Int,

`    `val isRecyclable: Boolean,

`    `val channel: Int

)

data class Inventory(

`    `val bills: List<Denomination>,

`    `val coins: List<Denomination>

)

**2.2.2.6.3 InventoryProvider 实现**

kotlin

interface CashDeviceApi {

`    `@GET("api/CashDevice/GetCurrencyAssignment")

`    `suspend fun getCurrencyAssignment(

`        `@Query("deviceID") deviceId: String

`    `): Response<List<CurrencyAssignmentItem>>

}

class InventoryProvider(

`    `private val api: CashDeviceApi,

`    `private val deviceId: String

) {

`    `suspend fun fetchInventory(): Inventory {

`        `val response = api.getCurrencyAssignment(deviceId)

`        `if (!response.isSuccessful) throw IOException("Failed to fetch inventory")

`        `val items = response.body() ?: emptyList()

`        `*// 根据type区分纸币(1)和硬币(2?) 需参考文档*

`        `val bills = items.filter { it.type == 1 }.map { it.toDenomination() }

`        `val coins = items.filter { it.type == 2 }.map { it.toDenomination() }

`        `return Inventory(bills, coins)

`    `}

`    `private fun CurrencyAssignmentItem.toDenomination() = Denomination(

`        `value = value,

`        `countryCode = countryCode,

`        `stored = stored,

`        `isRecyclable = isRecyclable,

`        `channel = channel

`    `)

}

**2.2.2.6.4 ChangeGuard 实现**

kotlin

class ChangeGuard(

`    `private val minChangeReserve: Long = 500  *// 5€ 保留金*

) {

`    `fun evaluate(

`        `target: Long,

`        `paid: Long,

`        `inventory: Inventory

`    `): GuardResult {

`        `val allDenoms = inventory.bills + inventory.coins

`        `val safe = mutableListOf<Denomination>()

`        `val unsafe = mutableListOf<Denomination>()

`        `for (denom in allDenoms) {

`            `val isSafe = evaluateDenomination(denom, target, paid, inventory, minChangeReserve)

`            `if (isSafe) safe.add(denom) else unsafe.add(denom)

`        `}

`        `return GuardResult(unsafe, safe, "评估完成")

`    `}

`    `private fun evaluateDenomination(

`        `d: Denomination,

`        `target: Long,

`        `paid: Long,

`        `inventory: Inventory,

`        `reserve: Long

`    `): Boolean {

`        `val newPaid = paid + d.value

`        `if (newPaid < target) return true  *// 无需找零，安全*

`        `val need = newPaid - target

`        `*// 模拟扣除这张纸币后的库存*

`        `val tempInventory = inventory.copy(

`            `bills = inventory.bills.map {

`                `if (it.channel == d.channel) it.copy(stored = it.stored - 1) else it

`            `}

`        `)

`        `return canMakeChangeWithReserve(need, tempInventory, reserve)

`    `}

`    `private fun canMakeChangeWithReserve(

`        `need: Long,

`        `inventory: Inventory,

`        `reserve: Long

`    `): Boolean {

`        `val totalAvailable = inventory.bills.sumOf { it.value \* it.stored } +

`                `inventory.coins.sumOf { it.value \* it.stored }

`        `if (totalAvailable - need < reserve) return false

`        `return canMakeChange(need, inventory.bills + inventory.coins)

`    `}

`    `private fun canMakeChange(need: Long, denoms: List<Denomination>): Boolean {

`        `val maxAmount = denoms.sumOf { it.value \* it.stored }

`        `if (need > maxAmount) return false

`        `val dp = BooleanArray(need.toInt() + 1)

`        `dp[0] = true

`        `for (denom in denoms) {

`            `val value = denom.value.toInt()

`            `val count = denom.stored

`            `for (k in 1..count) {

`                `for (x in need.toInt() downTo value) {

`                    `if (dp[x - value]) dp[x] = true

`                `}

`            `}

`        `}

`        `return dp[need.toInt()]

`    `}

}

**说明**：

- 算法对所有面额一视同仁，不再按阈值默认放行小面额，从而避免因小面额投入导致找零不足的风险。
- minChangeReserve 用于确保找零后库存仍有至少一定金额的零钱，防止零钱池被掏空。

**2.2.2.6.5 DenominationController 实现**

kotlin

interface CashDeviceApi {

`    `@POST("api/CashDevice/SetDenominationInhibits")

`    `suspend fun setDenominationInhibits(

`        `@Query("deviceID") deviceId: String,

`        `@Body request: InhibitsRequest

`    `): Response<Unit>

}

data class InhibitsRequest(

`    `val ValueCountryCodes: List<String>, *// e.g. ["500 GBP", "1000 GBP"]*

`    `val Inhibit: Boolean

)

class DenominationController(

`    `private val api: CashDeviceApi,

`    `private val deviceId: String

) {

`    `suspend fun applyInhibits(unsafe: List<Denomination>) {

`        `*// 先获取当前所有面额（或从外部传入）*

`        `*// 这里简化为直接禁用unsafe，放行其他*

`        `val inhibitList = unsafe.map { "${it.value} ${it.countryCode}" }

`        `val request = InhibitsRequest(inhibitList, true)

`        `api.setDenominationInhibits(deviceId, request)

`        `*// 更稳健做法：先获取当前所有面额，生成一个完整列表，对safe设置Inhibit=false，对unsafe设置true*

`    `}

}

**2.2.2.6.6 PaymentSession 核心实现（简化）**

kotlin

class PaymentSession(

`    `private val deviceId: String,

`    `private val inventoryProvider: InventoryProvider,

`    `private val changeGuard: ChangeGuard,

`    `private val denomController: DenominationController,

`    `private val payoutOrchestrator: PayoutOrchestrator,

`    `private val failureHandler: FailureHandler,

`    `private val onStateChanged: (PaymentState) -> Unit

) {

`    `var paidAmount: Long = 0

`        `private set

`    `var targetAmount: Long = 0

`        `private set

`    `var state: PaymentState = PaymentState.Idle

`        `private set(value) {

`            `field = value

`            `onStateChanged(value)

`        `}

`    `suspend fun startSession(target: Long) {

`        `targetAmount = target

`        `paidAmount = 0

`        `state = PaymentState.SessionActive

`        `refreshInhibits()

`        `enableAcceptor()

`        `state = PaymentState.Receiving

`    `}

`    `suspend fun handleCashEvent(event: CashEventResponse) {

`        `if (state !is PaymentState.Receiving) return

`        `when (event.eventTypeAsString) {

`            `"STORED", "STACKED", "VALUE\_ADDED", "COIN\_CREDIT" -> {

`                `paidAmount += event.value

`                `refreshInhibits()

`                `if (paidAmount >= targetAmount) {

`                    `state = PaymentState.PaymentCompleting

`                    `processPayout()

`                `}

`            `}

`        `}

`    `}

`    `private suspend fun refreshInhibits() {

`        `val inventory = inventoryProvider.fetchInventory()

`        `val result = changeGuard.evaluate(targetAmount, paidAmount, inventory)

`        `denomController.applyInhibits(result.unsafeDenoms)

`    `}

`    `private suspend fun processPayout() {

`        `state = PaymentState.PayoutInProgress

`        `val change = paidAmount - targetAmount

`        `val payoutResult = if (change > 0) {

`            `payoutOrchestrator.payout(deviceId, change, "GBP") *// 货币从配置获取*

`        `} else {

`            `PayoutResult.Success

`        `}

`        `when (payoutResult) {

`            `is PayoutResult.Success -> {

`                `state = PaymentState.Completed

`                `*// 关闭会话，清理*

`            `}

`            `is PayoutResult.Failure -> {

`                `state = PaymentState.PayoutFailed

`                `failureHandler.handlePayoutFailure(this, payoutResult)

`            `}

`        `}

`    `}

`    `private suspend fun enableAcceptor() {

`        `*// 调用 EnableAcceptor API*

`    `}

`    `*// 其他方法：cancel(), refund() 等*

}

**2.2.2.6.7 PayoutOrchestrator 实现**

kotlin

interface CashDeviceApi {

`    `@POST("api/CashDevice/DispenseValue")

`    `suspend fun dispenseValue(

`        `@Query("deviceID") deviceId: String,

`        `@Body request: DispenseRequest

`    `): Response<Unit>

}

data class DispenseRequest(

`    `val Value: Long,

`    `val CountryCode: String

)

class PayoutOrchestrator(

`    `private val api: CashDeviceApi,

`    `private val deviceStatusProvider: suspend () -> List<DeviceEvent> *// 轮询获取状态*

) {

`    `suspend fun payout(deviceId: String, amount: Long, currency: String): PayoutResult {

`        `val request = DispenseRequest(amount, currency)

`        `val response = api.dispenseValue(deviceId, request)

`        `if (!response.isSuccessful) {

`            `return PayoutResult.Failure("Dispense request failed", response.code().toString())

`        `}

`        `*// 轮询等待找零完成*

`        `return pollForPayoutResult()

`    `}

`    `private suspend fun pollForPayoutResult(): PayoutResult {

`        `var attempts = 0

`        `while (attempts < 30) { *// 最多等待6秒（200ms\*30）*

`            `val events = deviceStatusProvider()

`            `for (event in events) {

`                `if (event.type == "DispenserTransactionEventResponse") {

`                    `*// 假设有stateAsString字段*

`                    `val state = (event as? DispenserTransactionEventResponse)?.stateAsString

`                    `return when (state) {

`                        `"COMPLETED" -> PayoutResult.Success

`                        `"ERROR" -> PayoutResult.Failure("Dispense error", null)

`                        `else -> continue

`                    `}

`                `}

`            `}

`            `delay(200)

`            `attempts++

`        `}

`        `return PayoutResult.Failure("Timeout waiting for payout", null)

`    `}

}

**2.2.2.6.8 FailureHandler 实现**

kotlin

class FailureHandler(

`    `private val context: Context,

`    `private val onUserAction: (UserAction) -> Unit

) {

`    `sealed class UserAction {

`        `object Retry : UserAction()

`        `object Refund : UserAction()

`        `object Cancel : UserAction()

`    `}

`    `suspend fun handlePayoutFailure(session: PaymentSession, result: PayoutResult.Failure) {

`        `*// 记录日志*

`        `logError("Payout failed: ${result.reason}")

`        `*// 通知UI显示选项*

`        `withContext(Dispatchers.Main) {

`            `showFailureDialog()

`        `}

`        `*// 等待用户选择（通过回调）*

`        `val action = awaitUserAction()

`        `when (action) {

`            `UserAction.Retry -> session.retryPayout()

`            `UserAction.Refund -> session.refund()

`            `UserAction.Cancel -> session.cancel()

`        `}

`    `}

`    `suspend fun handleJam(event: CashEventResponse, session: PaymentSession) {

`        `*// 卡币处理：暂停接收，记录金额，提示用户*

`        `session.pauseAcceptor()

`        `*// ...*

`    `}

}

**2.2.2.7 错误处理与恢复（卡币、找零失败与退款策略）**

**一、异常分类原则**

现金支付异常分为三类：

|类型|是否涉及人工|是否允许自动退款|终态|
| :- | :- | :- | :- |
|A类：设备健康但支付未完成|否|是|Cancelled|
|B类：设备事务失败|视情况|尝试一次|Failed/Manual|
|C类：物理故障（卡币/开门等）|是|否|Failed|

**二、A类异常 —— 部分支付/超时（设备健康）**

**触发条件**

- paidCents > 0 && paidCents < priceCents
- 设备状态健康（无 JAM / ERROR / CASHBOX\_REMOVED）
- 支付超时或用户主动取消

**处理策略**\
在满足以下条件时，允许自动退款：

- 设备允许执行 payout
- ChangeGuard 评估库存足够
- 未处于维护模式

**状态流转**

text

Receiving -- 超时/取消 --> RefundCandidate

RefundCandidate -- 条件满足 --> RefundInProgress

RefundInProgress -- COMPLETED --> Refunded

RefundInProgress -- ERROR --> RefundFailedManual

**成功结果**

- 订单标记为 CANCELLED
- 生成 RefundRecord
- resetSession()

**三、B类异常 —— 找零失败（设备事务异常）**

**触发条件**

- INCOMPLETE\_PAYOUT
- ERROR\_DURING\_PAYOUT
- DispenserTransactionEventResponse.ERROR

**处理策略**\
允许重试最多 N 次（建议 2 次）：

text

PayoutFailed -- Retry(<=2) --> PayoutInProgress

PayoutFailed -- RetryExceeded --> RefundFailedManual

若超过重试次数或设备状态恶化：

- 进入人工处理
- 生成 PendingSettlement

**UI 提示**

- 英语：The equipment malfunctions, please contact our staff.
- 德语：Sollte das Gerät nicht ordnungsgemäß funktionieren, wenden Sie sich bitte an unsere Mitarbeiter.

**四、C类异常 —— 物理故障（卡币/路径打开等）**

**定义**\
以下事件视为必须人工介入：

- NOTE\_HELD\_IN\_BEZEL
- NOTE\_PATH\_OPEN
- COIN\_MECH\_JAMMED
- JAM\_RECOVERY
- CASHBOX\_REMOVED
- DEVICE\_FULL

**原则**\
一旦进入物理故障状态：

- 立即停止接收
- 严禁自动退款
- 严禁重试 payout
- 强制进入人工处理流程

**状态流转**

text

Receiving -- 卡币事件 --> Jammed

PayoutInProgress -- 卡币事件 --> Jammed

Jammed -- 人工确认 --> Failed

**五、PendingSettlement（异常挂起机制）**

为防止断电或 APP 重启导致交易资金状态丢失，系统在以下情况必须生成 PendingSettlement：

- **卡币**（出现 NOTE\_HELD\_IN\_BEZEL / NOTE\_PATH\_OPEN / COIN\_MECH\_JAMMED 等事件，且 paidCents > 0）
- **退款失败**（已发起退款事务，但收到 ERROR/INCOMPLETE\_PAYOUT/ERROR\_DURING\_PAYOUT，且 paidCents > 0）
- **payout 事务闭环不确定**（已发起 DispenseValue/payout 指令，但在事务确认窗口内未收到明确闭环： COMPLETED 或 ERROR，且 paidCents > 0）
- **设备进入 ERROR 且 paidCents > 0**

**5.1 生成前提与严格约束**\
为避免误生成挂起记录，必须满足以下规则：

- paidCents = 0 时，严禁生成 PendingSettlement。
- “payout 事务闭环不确定”必须满足：
  - 已成功发送 payout 指令；
  - 超过确认等待窗口（建议 10 秒，可参数化）；在 Device Test 中的 Timeouts 可设置这个时间
  - 未收到 DispenserTransactionEventResponse = COMPLETED 或 ERROR；\
    才允许写入 PendingSettlement。
- 同一 sessionId 仅允许生成一条 PendingSettlement。

**5.2 记录字段**

- settlementId
- sessionId
- orderId
- paidCents
- reasonCode
- deviceSnapshot（包含设备状态、事件缓存、库存快照）
- createdAt

**5.3 启动恢复机制**\
APP 启动时若检测到未解决挂起记录：

text

Launch --> ManualInterventionRequired

**5.4 营业锁定规则**\
PendingSettlement 表示存在“未完成结算闭环的资金风险（money-at-risk）”。\
若满足以下条件：

**情况 A：paidCents > 0**\
系统必须：

- 禁止创建新订单
- 禁止进入 Selecting / Paying 状态
- 禁止启用现金接收器
- 显示异常金额与原因\
  必须后台管理员确认处理后方可恢复，管理员可以在后台管理 → 运营管理 → 订单 → PendingSettlement处理。

**情况 B：paidCents = 0**\
不生成 PendingSettlement，不影响营业。

**5.5 自动解除条件（仅限闭环补到场景）**\
若 PendingSettlement 已生成，但系统随后检测到明确闭环证据，则允许自动清除：

- 收到对应事务的 DispenserTransactionEventResponse = COMPLETED
- 或收到明确退款成功闭环事件（与 sessionId 匹配）\
  除上述情况外，严禁自动清除，必须人工确认，管理员在后台管理 → 运营管理 → 订单 → PendingSettlement处理。

**5.6 UI 行为**\
当处于 ManualInterventionRequired：

- 禁止继续收款
- 显示异常金额
- 显示异常原因
- 引导进入后台处理

**六、人工处理流程（后台）**\
`	`当订单存在 PendingSettlement 且 paidCents > 0 时，必须人工确认处理。

**6.1 后台操作步骤**

- 进入后台管理系统
- 查询异常订单（通过 orderId 或 settlementId）
- 查看：
  - 已收金额（paidCents）
  - 事件日志
  - 设备状态快照
- 根据实际情况：
  - 线下退款
  - 或确认钞票已取回
  - 或确认设备已完成出币但事件丢失
- 点击“确认故障，关闭订单”

**6.2 系统行为**\
确认后系统执行：

- 标记订单为 FAILED
- 记录操作员 ID
- 记录处理时间
- 标记线下退款状态（内部字段：未退款 / 已退款）
- 清除 PendingSettlement
- 调用 resetSession()
- 恢复至 IDLE

**七、报表字段建议（补充）**

|字段|说明|
| :- | :- |
|订单号|唯一标识|
|交易时间|开始时间|
|目标金额|应付金额|
|已收金额|实际收款|
|异常类型|A/B/C 分类|
|状态|CANCELLED / FAILED|
|是否自动退款|true/false|
|故障处理时间|人工时间|
|操作员|处理人ID|
|线下退款状态|内部字段|

**八、恢复机制**\
所有异常终态（Refunded / Failed）最终调用：

text

resetSession()

恢复内容：

- DisableAcceptor
- 重置 Inhibit
- 清空 sessionPaidCents
- 状态回到 IDLE

**2.2.2.8 附录：ITL SDK 关键API参考**

|功能|端点|方法|说明|
| :- | :- | :- | :- |
|获取库存|GetCurrencyAssignment|GET|返回各通道面额及数量|
|设置抑制|SetDenominationInhibits|POST|禁用/放行面额|
|启用接收器|EnableAcceptor|POST|允许投币|
|禁用接收器|DisableAcceptor|POST|停止接收|
|执行找零|DispenseValue|POST|支付指定金额|
|轮询状态|GetDeviceStatus|GET|获取事件列表|
|建立连接|OpenConnection|POST|初始化设备，获取 deviceID|

**2.2.3 设备层核心原则（强化版）**

- 只回答“硬件现在是什么状态/结果”，不回答“我应该做什么”。
- 所有驱动必须提供同步/异步两种接口，以便状态管理层根据场景选择。
- 错误通过统一错误码 + 详细消息上报，由状态管理层决策。
- 必须提供模拟驱动实现，用于单元测试与脱机演示。
- **严禁在设备层实现任何业务重试、自动重连、会话状态缓存等逻辑。**

**2.3 状态管理层与设备层的交互边界**

**3.1**: 状态管理层仅通过设备层暴露的标准化接口获取硬件状态或执行操作，绝不直接发送串口指令或解析协议。

**示例：现金支付交互（V3.4 规范）**

|状态管理层动作|调用的设备层接口|设备层职责|
| :- | :- | :- |
|进入 Paying\_Cash|cash\_device.enableAcceptor(true)|发送 EnableAcceptor 指令，启用接收器|
|轮询设备状态获取现金事件|cash\_device.getDeviceStatus()|返回设备状态及事件列表（包含 CashEventResponse）|
|解析 CashEventResponse 累加金额|-|-|
|达到目标金额后执行找零|cash\_device.dispenseChange(amount)|执行找零，返回找零结果|
|检测找零能力（可选）|cash\_device.getChangeStatus()|返回能否找零、缺少面额|
|超时未投币|cash\_device.enableAcceptor(false)|关闭接收器|
|定期监测设备健康状态（独立任务）|cash\_device.getDeviceStatus()|返回设备在线/故障状态|

**说明**：

- 轮询设备状态用于两个目的：一是在 Paying\_Cash 中获取现金事件以累加金额，二是独立的健康监测任务。两者调用同一接口，但由状态管理层根据上下文处理。
- 现金事件包括 STORED、STACKED、VALUE\_ADDED、COIN\_CREDIT 等，状态管理层在收到这些事件时累加 sessionPaidCents。

**3.2: 状态监测专用流程（独立于支付轮询）**：

- 状态管理层启动一个独立的定时任务（间隔 500ms），调用 cash\_device.getDeviceStatus() 更新所有现金设备的健康状态。
- 若连续 3 次状态异常，状态管理层应立即禁用现金支付入口，并提示用户“现金设备故障，请使用其他支付方式”，如用户当前选择的是英语，则提示内容为“Cash payment equipment malfunction, please use alternative payment methods.”，当用语言是德语，显示“ Das Bargeldzahlungsgerät ist defekt. Bitte nutzen Sie alternative Zahlungsmethoden.”
- 为避免支付进行中因健康轮询瞬态异常而误触发控制行为，规定如下：

  • 当 WashFlowState = Paying\_Cash 或 PaymentSessionActive 时：\
  -- 健康监测线程仅允许读取设备状态（只读）, 健康监测线程允许记录异常计数、记录日志与更新设备健康缓存，但不得修改 PaymentSession 状态、不得触发 resetSession()、不得触发任何订单状态变更。\
  -- 禁止触发任何控制性动作，包括但不限于：\
  • EnableAcceptor(false)\
  • SetAutoAccept(false)\
  • SetDenominationInhibits(...)\
  • resetSession()\
  • 自动终止支付会话\
  • 支付期间如检测到 ERROR / DEVICE\_FULL / JAMMED 等状态：\
  -- 不得由健康监测线程直接处理\
  -- 必须将事件交由 PaymentSession 状态机统一决策\
  • 支付结束后，恢复健康监测线程的完整控制权限。

**2.4 订单层与设备层的关系**

订单层绝不允许直接调用设备层接口。订单层只与状态管理层或云端支付网关代理通信，所有交易凭证由状态管理层传递后存储。

**3. 状态机定义**

**3.1 设备状态（PLC 只读状态）**

|位/寄存器|名称|含义（V3 确认）|
| :- | :- | :- |
|217|故障|1=系统故障（急停/水压/电机等），0=无故障|
|240|就绪|1=允许启动（车到位/安全门禁通过），0=不允许|
|214|运行态|1=正在执行洗车程序，0=空闲|
|102|运行阶段|具体阶段值（0=空闲，1=泡沫，2=刷洗...）|
|752|完成标志|1=完整洗车流程结束（厂商：仅完整结束时变1，强制终止不变1）|
|MODE|启动请求|写1脉冲启动，PLC自动清零，洗车中写入被忽略|
|M60|强制终止|写1脉冲，PLC立即终止程序|
|M71|暂停/继续|写1脉冲切换暂停状态|

**3.1.1 MODE寄存器定义（洗车套餐启动指令）**

MODE寄存器对应多个不同的洗车套餐，每个套餐对应一个独立的PLC位地址。APP根据用户选择的套餐，在 Start\_SendingMode 状态写入对应MODEL的脉冲指令。具体定义如下：

|模式|业务名称（英语）|业务名称（德语）|PLC位地址|Modbus线圈地址（十进制）|Modbus线圈地址（十六进制）|写指令（ASCII）|
| :- | :- | :- | :- | :- | :- | :- |
|Mode1|Basic Wash|Basic Wäsche|M261 (2310)|2309|0x0905|3A30313035303930354646303045440D0A|
|Mode2|Standard Wash|Standard Wäsche|M262 (2311)|2310|0x0906|3A30313035303930364646303045430D0A|
|Mode3|Premium Wash|Premium Wäsche|M260 (2309)|2308|0x0904|3A30313035303930344646303045450D0A|
|Mode4|VIP Wash|VIP Wäsche|M264 (2313)|2312|0x0908|3A30313035303930384646303045410D0A|

**说明**：

- 所有指令均为 Modbus ASCII 格式，功能码05（写单个线圈），数据为 FF00（表示 ON），发送一次脉冲即可启动对应模式。
- Modbus 地址 = PLC位地址 - 1（例如 M261 对应 PLC 地址 2310，Modbus 地址为 2309）。
- 指令中的 LRC 校验已正确计算，可直接使用。
- 业务名称（英语/德语）为示例，实际运营中可根据需要配置或本地化，但底层指令与模式的对应关系不可变更

**3.2 APP 流程状态（WashFlowState）**

|状态|说明|关键 PLC 条件|APP 动作（设备层调用）|下一步迁移|
| :- | :- | :- | :- | :- |
|Idle|首页，轮询快照|-|plc.read\_all()<br>cash.getDeviceStatus()（独立定时任务）|点击开始→Selecting|
|Selecting|选择套餐/附加服务|仅需 217=0 即可继续|plc.read\_217()|确认→PaymentSelecting|
|PaymentSelecting|选择支付方式|仅需 217=0|无设备调用|选卡→Paying\_Card<br>选现金→Paying\_Cash|
|Paying\_Card|POS 支付中|过程中若 217=1→失败|pos.start\_payment()<br>pos.poll\_transaction()|成功→PaymentAuthorized<br>失败→PaymentSelecting|
|Paying\_Cash|现金收款/找零|217=0|1\. 检查设备状态（GetDeviceStatus）<br>2\. 拉取库存、评估策略、下发抑制<br>3\. cash.enableAcceptor(true)<br>4\. 轮询 CashEventResponse 累加金额，实时更新UI（应付/已付/差额）<br>5\. 超时处理|成功（paid ≥ target）→ PaymentAuthorized<br>超时 → 取消支付 → PaymentSelecting<br>故障 → Manual/Failed|
|PaymentAuthorized|支付成功，等待进入 GateCheck|无|固化交易 ID，准备 GateCheck|→GateCheck\_Wait240|
|GateCheck\_Fault217|故障阻断|217=1|plc.read\_217()（只读不复位）|217=0 → GateCheck\_Wait240|
|GateCheck\_Wait240|等待 PLC 就绪|240=0|plc.read\_240() 策略轮询|240=1 → Start\_SendingMode<br>**超时 → Manual（提示用户等待，不退款）**|
|GateCheck\_Wait752|可选等待点（默认关闭，需现场确认启用）|752=1（启用时条件）|plc.read\_752() 策略轮询|满足条件 → GateCheck\_Wait240 或 Start|
|Start\_SendingMode|发送启动请求|必须：217=0 且 240=1|根据所选套餐，plc.write\_mode(1) 写入对应 MODEL 的脉冲指令（如 Mode1、Mode2 等）|写完 → Start\_Wait214|
|Start\_Wait214|等待 PLC 进入运行态|214=0 → 等待|plc.read\_214() 策略轮询|214=1 → Running\_Wait102End<br>**超时 → Manual（提示等待）**|
|Running\_Wait102End|运行监控|214=1 或 102≠空闲|plc.read\_102/214()<br>（仅监控,不提供用户控制按钮）|102 结束 或 214 = 0 → Completed|
|Completed|服务正常完成|结束态（214=0/）|Completed<br>清理会话状态，不触发打印（打印已在 PaymentAuthorized 完成）|→ Idle|
|TimeoutHandling|超时处理|-|仅提示/延长，**不退款**|执行策略后 → Retry|
|ManualInterventionRequired|需人工介入|-|展示原因|-|
|Failed|支付失败|-|多语言提示|-|

**3.3 订单状态（OrderState）**

独立于 WashFlowState，反映订单在交易维度的生命周期：

|订单状态|含义|触发时机|
| :- | :- | :- |
|ORDER\_PAYMENT\_INIT|订单创建，待支付|用户点击开始，生成订单|
|ORDER\_PAID|已支付|支付成功（PaymentAuthorized）|
|**ORDER\_PENDING\_CONFIRMATION**|**MODE已发送，等待PLC运行确认**|**发送 MODE 成功后立即设置**|
|**ORDER\_COMPLETED**|**服务完成（确认PLC运行后）**|**检测到 PLC 进入运行态（214=1 或 102≠0）后设置**|
|ORDER\_REFUNDING|退款中|进入 Refunding 状态|
|ORDER\_REFUNDED|已退款|Refunded 状态到达|
|ORDER\_MANUAL|需人工处理|ManualInterventionRequired 状态到达|
||||
**映射关系**：

- ORDER\_PENDING\_CONFIRMATION = 发送 MODE 后进入。
- ORDER\_COMPLETED = 确认 PLC 运行后进入（服务已启动确认），**不代表洗车流程已自然结束**；洗车结束属于设备侧运行过程，不作为订单终态判断。。
- ORDER\_REFUNDED = 退款成功。
- ORDER\_MANUAL = 需人工介入（运营跟进）。
- 订单一旦进入上述终态，不再允许任何操作。

**4. 状态迁移与订单生命周期映射**

**4.1 支付至 GateCheck 阶段**

Idle → Selecting → PaymentSelecting → Paying\_Card/Paying\_Cash → PaymentAuthorized\
订单状态变化：ORDER\_PAYMENT\_INIT → ORDER\_PAID

- 支付成功必须经过 PaymentAuthorized 状态，不得跳过。
- 支付过程中若设备故障，状态管理层根据错误类型引导重试或进入 ManualInterventionRequired。
- 打印触发规则：\
  当 PaymentSession 状态进入 PaymentAuthorized 时，系统必须立即打印小票。打印行为仅与支付成功（Financial Completion）相关，不依赖 GateCheck 或 PLC 启动结果。即使后续未能进入 GateCheck 或 PLC 未启动，用户仍然获得支付凭证。

**4.2 GateCheck 与启动阶段（V3.4 修正版）**

PaymentAuthorized → GateCheck\_Wait240（或 GateCheck\_Fault217） → Start\_SendingMode → Start\_Wait214

- **订单状态**：保持 ORDER\_PAID → 进入 Start\_SendingMode **后立即改为 ORDER\_PENDING\_CONFIRMATION**（MODE 写入成功），然后等待 PLC 运行确认；若检测到运行态则变为 ORDER\_COMPLETED；若超时未运行则变为 ORDER\_MANUAL。
- **硬件条件**：217 = 0 且 240 = 1
- **启动指令**：根据用户选择的套餐，调用 plc.write\_mode(1) 写入对应 MODEL 的脉冲指令（如 Mode1、Mode2 等）。指令定义见 3.1.1 节。APP 不等待写完成，直接进入 Start\_Wait214 开始轮询 214。
- **写 MODE 失败处理**：若写操作异常（网络超时、PLC无响应），应重试有限次数（如3次），否则进入 ManualInterventionRequired。
- **防呆**：若当前已在 Start\_Wait214 或 Running 状态，禁止再次执行写 MODE。

**注意**：订单在发送 MODE 后即进入待确认，后续洗车过程仅作为流程展示，不再影响订单终态（除非超时未运行需人工介入）。

**4.2.1 MODE 写入确认机制（财务安全补强）**

为避免出现“订单完成但设备未实际执行”的财务风险，订单完成必须采用两阶段确认机制。

**阶段一：MODE 写入成功**\
当 MODE 写入接口返回成功时：

text

OrderState = ORDER\_PENDING\_CONFIRMATION

此时订单尚未最终完成。

**阶段二：PLC 执行确认**\
在 MODE 写入成功后的 1500ms 内，这个时间需要在Device Test/timeouts下面自定义，必须检测到以下任一条件：

- 214 == 1（设备进入运行）
- 102 != 0（模式寄存器确认）\
  若满足：

`		`OrderState = ORDER\_COMPLETED

若未满足（超时未检测到）：

`		`OrderState = ORDER\_MANUAL

` `同时生成 ServiceTicket 并记录异常, 写入 failureReasonCode = PLC\_CONFIRM\_TIMEOUT（或等价字段）

**4.3 运行监控与完成阶段（V3.4 修正版）**

Start\_Wait214 → Running\_Wait102End → Completed

- **订单状态**：已为 ORDER\_COMPLETED（若已确认运行），**保持不变**。
- **轮询 214 和 102**：
  - 214 = 1 或 102 ≠ 空闲 → 进入 Running\_Wait102End（表示洗车正在进行，在APP首面底部状态栏显示状态）。
  - 214 = 0 且 102 = 空闲 → 洗车自然结束，进入 Completed（WashFlowState 状态，仅用于 UI 提示洗车完成，不影响订单）。
- **M60（强制终止）**：用户触发时 APP 调用 plc.write\_m60(1)，PLC 终止程序。
  - 收到 M60 后，APP 等待 PLC 状态稳定（214 = 0），然后进入 TimeoutHandling → 根据已服务时长/金额策略决定后续（**但 APP 仅提示，不退款，不修改订单状态**）。
- **M71（暂停/继续）**：用户触发时 APP 调用 plc.write\_m71(1)，PLC 切换暂停状态，APP 轮询不受影响，仅界面展示暂停提示。
- 标准版 APP 不向普通用户提供 M60（强制终止）和 M71（暂停/继续）按钮。这两个指令仅用于后台调试、管理员操作或物理按钮控制（由现场工作人员使用）。若因特殊需求需在 APP 中提供，必须遵循以下原则：
- 按钮仅在 Running\_Wait102End 状态显示。
- 触发后订单状态不变（仍为 ORDER\_COMPLETED）
- 需明确提示用户“操作不影响订单状态，不退款”。

**关键点**：

- 订单在确认运行后已锁定为 ORDER\_COMPLETED，后续任何洗车过程中的异常（如故障、强制终止）都不会改变订单状态，仅影响 UI 提示和可能的用户交互（如重试、退款需人工处理）。
- Completed 状态仅为 APP 流程节点，表示洗车过程自然结束，可打印小票、清理会话等。

**4.4 异常处理策略（V3.4 强化设备状态异常处理）**

根据 V3.4 规范的最新调整，对异常处理场景进行如下修订，确保与 **事件驱动现金支付**、**订单终态与服务解耦** 的原则保持一致。

|异常场景|处理行为|订单终态|
| :- | :- | :- |
|**GateCheck\_Wait240 超时**|策略化延长时间的提示（英语：Please wait a  moment，德语：Bitte warten Sie einen Moment.）之后进入 ManualInterventionRequired|进入 ManualInterventionRequired 时，订单状态设为 ORDER\_MANUAL，同时生成 ServiceTicket 并记录异常原因|
|**Start\_Wait214 超时**|同上，进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**运行中 217=1（故障）**|启动故障等待计时，若 short timeout 内恢复（217=0）则继续运行；否则进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**运行中超时（运行时间超大限制）**|指洗车机运行时间超过预设最大时长（如因卡滞等原因），APP 仅提示用户等待，英语：Please wait a  moment，德语：Bitte warten Sie einen Moment.）之后进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**强制终止 M60**|用户触发 M60 后，APP 根据已服务比例提示用户（如“已服务部分时长”），但**退款由人工线下处理**，订单状态保持 COMPLETED（若已确认运行）|**ORDER\_COMPLETED**|
|**POS 支付失败**|返回 PaymentSelecting，订单仍为 ORDER\_PAYMENT\_INIT|-|
|**POS 退款失败**|记录失败原因，进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**现金设备获取库存超时（GetCurrencyAssignment）**|状态管理层记录失败次数，按策略重试；连续失败超阈值 → 提示人工，禁用现金支付入口|**ORDER\_MANUAL**|
|**现金设备 GetDeviceStatus 连续失败**|状态管理层判定设备离线，立即禁用现金支付入口，引导用户使用其他支付方式；已有支付会话进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**现金找零失败（缺零钱）**|提示用户可选其他支付方式或人工退款，进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**纸币器卡钞**|禁用接收，提示人工，进入 ManualInterventionRequired|**ORDER\_MANUAL**|
|**打印机故障**|记录错误，订单继续，后台记录待补打标记|**不影响终态**|

**关键规则**：

- 所有超时值必须在后台管理中(后台管理/Timeouts)可配置（按 MODEL1-4 分别设置），严禁硬编码。
- 运行中故障恢复：PLC 在故障恢复后若仍在运行态（214=1），则 APP 继续监控，不重新发送 MODE。
- 禁止自动重发启动：任何情况下，APP 不得在未收到人工确认或订单重置的情况下自动写 MODE。
- 支付设备错误：状态管理层必须捕获设备层抛出的所有异常，并根据错误码映射到用户友好的提示语。
- 设备层不做自动重连策略；状态管理层可在 **Idle/Startup** 阶段按限频策略重连，支付会话进行中禁止隐式重连。

**5. 订单终态规则（唯一合法终态）**

订单只能以下列三种状态之一结束：

**1. ORDER\_COMPLETED**

- **触发条件**：发送 MODE 后进入 ORDER\_PENDING\_CONFIRMATION，确认 PLC 运行后进入 ORDER\_COMPLETED。
- **含义**：服务已启动，资金可结算，后续问题由人工处理。

**2. ORDER\_REFUNDED**

- **触发条件**：Refunded 状态到达（退款成功）。
- **含义**：已全额或部分退款，订单终止。

**3. ORDER\_MANUAL**

- **触发条件**：ManualInterventionRequired 状态到达。
- **含义**：系统无法自动完成，需人工介入处理，处理后人工关闭订单。

**禁止状态**：

- 不允许订单处于“支付成功但未启动且未退款”的永久挂起状态。一旦支付成功，若因设备故障无法进入 GateCheck 或启动超时，则进入 ManualInterventionRequired，订单状态变为 ORDER\_MANUAL。若 MODE 发送成功但未确认运行，则进入 ORDER\_PENDING\_CONFIRMATION，超时后转为 ORDER\_MANUAL。

**6. 新订单准入规则（与订单状态解耦）**

**核心原则**：

- 新订单能否开始，由设备物理状态决定，不由历史订单状态决定。
- 准入条件 = PLC 无故障（217=0）且就绪（240=1）（即 GateCheck 通过条件）。
- **同时，新订单只能在 WashFlowState == Idle 时创建**。虽然准入条件依赖设备状态，但 APP 首页轮询时会同时检查当前是否有进行中的订单流程（即 WashFlowState 是否为 Idle）。若存在未完成的订单（如处于 GateCheck\_Wait240、Start\_Wait214、ManualInterventionRequired 等状态），开始按钮置灰，防止并发订单。

**实现方式**：

- APP 首页轮询 PLC 状态，只有当 217=0 且 240=1 且 WashFlowState == Idle 时，才允许用户选择套餐进行支付。
- 即使上一个订单异常结束（ORDER\_MANUAL），只要设备满足条件且无进行中流程，新订单即可开始。

**支付设备状态检查（V3.4 新增）**：

- APP 首页需显示现金设备健康状态（在线/离线/故障）。
- 若所有支付方式均不可用（如现金设备离线且 POS 离线），首页所有套餐不能选择，英语提示“No payment methods are currently available.”，德语显示” Derzeit stehen keine Zahlungsmethoden zur Verfügung.”
- 现金设备状态由独立的 DeviceStatusMonitor 每 500ms 轮询 GetDeviceStatus 更新。

**7. 不可违反的硬规则（V3.4 红线）**

- **支付后必须经过 GateCheck 才能启动**
  - 严禁支付成功直接写 MODE。
- **发送 MODE 即代表订单进入待确认，确认运行后订单完成**
  - 订单终态需经两阶段确认，超时未运行转人工。
- **禁止自动重新发送启动请求**
  - 任何情况下，APP 不得自动重试写 MODE。
- **M60/M71 仅允许由用户主动触发**
  - APP 不可自动调用强制终止。
- **752 不作为唯一门禁依据**
  - 默认关闭 GateCheck\_Wait752，除非现场反复验证后明确启用，且必须配合 240 共同判断。
- **所有等待点必须策略化超时**
  - 不得使用固定超时值。超时后根据场景提示等待或进入人工，**绝不自动退款**。
- **订单状态机与设备状态机必须分离**
  - 禁止用订单状态直接控制设备准入。
- **设备层驱动必须实现接口，禁止业务逻辑直接操作硬件**
  - 状态管理层只能通过注入的接口调用设备层，严禁在状态机代码中出现串口读写、协议解析等。
- **所有硬件驱动必须提供模拟实现**
  - 单元测试及脱机演示环境必须依赖模拟驱动，不可依赖真实硬件。
- **现金设备连接必须保持长连接，严禁在支付会话中重连**
  - OpenConnection 仅在 APP 启动时调用一次，支付过程中不得因任何错误触发重连。
  - 设备状态通过 GetDeviceStatus 轮询监测，轮询间隔 350ms - 500ms。
- **禁止设备层自动重连**
  - 设备层驱动不得包含任何自动重试、自动恢复逻辑。
  - 重连决策仅允许由状态管理层在用户明确操作或系统启动时发起。
  - 状态管理层在 Idle 状态可按指数退避策略触发重连；\
    支付会话中禁止重连

**8. 策略化等待与超时配置（示例）**

`		`所有等待点超时参数均需从配置中心获取，按 MODEL1-4 及支付方式可独立设置。**所有退款动作均已移除，改为提示用户等待或进入人工**。

|等待点|软超时 (soft timeout)|硬超时 (hard timeout)|硬超时动作|
| :- | :- | :- | :- |
|GateCheck\_Wait240|120s|300s|进入 ManualInterventionRequired，提示用户等待（英语：Please wait a moment，德语：Bitte warten Sie einen Moment.）|
|Start\_Wait214|10s|30s|进入 ManualInterventionRequired，提示用户等待|
|Running\_Wait102End|MODEL基准时间+5min|基准时间+15min|进入 ManualInterventionRequired，提示用户等待|
|Paying\_Cash（投币超时）|60s|180s|取消支付 → PaymentSelecting|
|Paying\_Cash（轮询超时）|5s（连续3次）|30s（连续6次）|提示人工，禁用现金支付入口|
|Paying\_Card（交易超时）|30s|60s|失败 → PaymentSelecting|
|POS轮询交易结果|2s轮询，持续30s|30s无结果|失败 → PaymentSelecting|
|现金设备状态轮询|500ms|连续3次失败|禁用现金支付入口|

**配置方式**：\
`		`所有超时参数存放于Device Test/Timeouts或云端配置中心，APP启动时拉取，支持热更新。本地需保留默认值，供首次启动或网络不可用时使用。

**9. 状态机对照表（V3.4 完整版）**

|状态|说明|设备条件|APP动作（设备层调用）|订单状态|超时策略|
| :- | :- | :- | :- | :- | :- |
|Idle|首页，轮询快照|-|plc.read\_all()<br>cash.getDeviceStatus()（独立定时任务）|-|-|
|Selecting|选择套餐|217=0|plc.read\_217()|ORDER\_PAYMENT\_INIT|-|
|PaymentSelecting|选择支付方式|217=0|-|ORDER\_PAYMENT\_INIT|-|
|Paying\_Card|POS 支付|217=0|pos.start\_payment()<br>pos.poll\_transaction()|ORDER\_PAYMENT\_INIT|交易超时|
|Paying\_Cash|现金收款|217=0|1\. 检查设备状态<br>2\. 拉库存、评估、下发抑制<br>3\. cash.enableAcceptor(true)<br>4\. 轮询收款，实时更新UI|ORDER\_PAYMENT\_INIT|投币超时|
|PaymentAuthorized|支付成功|-|-|ORDER\_PAID|-|
|GateCheck\_Fault217|故障阻断|217=1|plc.read\_217()|ORDER\_PAID|-|
|GateCheck\_Wait240|等待就绪|240=0|plc.read\_240()|ORDER\_PAID|超时 → Manual（人工）|
|GateCheck\_Wait752|可选等待点（默认关闭）|752=1|plc.read\_752()|ORDER\_PAID|-|
|Start\_SendingMode|发送启动|217=0 & 240=1|根据所选套餐，plc.write\_mode(1) 写入对应 MODEL 的脉冲指令|**ORDER\_PENDING\_CONFIRMATION**|-|
|Start\_Wait214|等待运行|214=0|plc.read\_214()|ORDER\_PENDING\_CONFIRMATION|超时 → Manual（人工）|
|Running\_Wait102End|运行监控|214=1|plc.read\_102/214()<br>plc.write\_m60/m71()|**ORDER\_COMPLETED** (若已确认运行)|运行超时 → Manual（人工）|
|Completed|服务完成|214=0 & 102=0|清理交易，打印小票|ORDER\_COMPLETED|-|
|TimeoutHandling|超时处理|-|仅提示/延长|ORDER\_COMPLETED (若之前已完成) 或 ORDER\_MANUAL|执行策略后 → Retry|
|ManualInterventionRequired|需人工介入|-|展示原因|ORDER\_MANUAL|-|
|Failed|支付失败|-|多语言提示|ORDER\_MANUAL|-|

**10. 附录A：现金设备层接口定义规范（Android/Kotlin）**

根据 V3.2 规范的核心要求——设备层严禁包含任何业务重连逻辑、仅负责指令收发与状态上报，以下提供完整的 Android（Kotlin + Coroutines）实现范例。所有代码均遵循单一职责原则，并与规范中的连接生命周期管理、状态监测独立轮询严格对齐。

**A.1 现金设备统一接口（Kotlin）**

kotlin

*/\*\**

` `\* 现金设备（纸币器/硬币器）统一接口

` `\* 所有具体设备驱动必须实现此接口

` `\* 方法均为挂起函数，便于在协调中调用

` `\*/

interface CashDevice {

`    `*/\*\**

`     `\* 建立与设备的通信连接

`     `\* 仅允许在APP启动时调用一次，支付会话中严禁调用

`     `\* @param port 串口号（0,1...）

`     `\* @param sspAddress SSP地址（纸币器通常为0，硬币器通常为16）

`     `\* @return true 表示连接成功

`     `\*/

`    `suspend fun openConnection(port: Int, sspAddress: Int): Boolean

`    `*/\*\**

`     `\* 获取设备实时健康状态

`     `\* 必须由独立的状态监测任务以350~500ms间隔轮询

`     `\*/

`    `suspend fun getDeviceStatus(): DeviceStatus

`    `*/\*\**

`     `\* 启用/禁用纸币/硬币接收器

`     `\* @param enable true = 允许接收，false = 禁止接收

`     `\*/

`    `suspend fun enableAcceptor(enable: Boolean): Boolean

`    `*/\*\**

`     `\* 获取当前各通道库存信息（用于找零评估）

`     `\* 对应 ITL SDK 的 GetCurrencyAssignment 接口

`     `\* 单位：分（cents）

`     `\* @return 面额及库存列表，其中 stored 表示 recycler 中可用数量

`     `\*/

`    `suspend fun getCurrencyAssignment(): List<Denomination>

`    `*/\*\**

`     `\* 执行找零

`     `\* @param amountCents 需找零金额（分）

`     `\* @return 找零结果（成功/失败/找零不足等）

`     `\*/

`    `suspend fun dispenseChange(amountCents: Int): DispenseResult

`    `*/\*\**

`     `\* 查询当前找零能力（缺零钱、面额可用性等）

`     `\*/

`    `suspend fun getChangeStatus(): ChangeStatus

`    `*/\*\**

`     `\* 设备是否在线（根据最近一次getDeviceStatus结果缓存）

`     `\* 该属性为只读，由驱动内部维护，状态管理层可直接读取

`     `\*/

`    `val isOnline: Boolean

}

*// 相关数据类定义*

data class DeviceStatus(

`    `val online: Boolean,          *// true = 设备响应正常*

`    `val errorCode: Int = 0,       *// 0表示无错误*

`    `val errorMessage: String? = null

)

data class Denomination(

`    `val countryCode: String,      *// 货币代码，如"EUR"*

`    `val value: Long,              *// 面额（分）*

`    `val stored: Int,              *// 当前库存数量*

`    `val isRecyclable: Boolean,    *// 是否可找零*

`    `val channel: Int              *// 通道号*

)

sealed class DispenseResult {

`    `object Success : DispenseResult()

`    `data class InsufficientChange(val missingAmount: Long) : DispenseResult()

`    `data class HardwareError(val reason: String) : DispenseResult()

}

data class ChangeStatus(

`    `val canMakeChange: Boolean,          *// 是否能够找零*

`    `val availableDenominations: List<Long>, *// 可找零面额列表（分）*

`    `val shortageAmount: Long = 0         *// 如果找零不足，缺少的金额（分）*

)

**A.2 具体设备实现示例（纸币器）**

kotlin

*/\*\**

` `\* SPECTRAL\_PAYOUT 纸币器驱动实现

` `\* 完全遵循设备层职责：仅收发指令，不包含任何重试、重连、业务决策

` `\*/

class SpectralPayoutDevice @Inject constructor(

`    `private val api: CashDeviceApi,        *// Retrofit 接口*

`    `private val deviceId: String = "SPECTRAL\_PAYOUT-0"

) : CashDevice {

`    `*// 设备连接是否已建立（仅用于标记，不代表当前物理状态）*

`    `private var \_isConnected = false

`    `*// 最近一次 GetDeviceStatus 的结果缓存*

`    `@Volatile

`    `private var \_lastStatus = DeviceStatus(online = false, errorCode = -1)

`    `override val isOnline: Boolean get() = \_lastStatus.online

`    `override suspend fun openConnection(port: Int, sspAddress: Int): Boolean {

`        `return try {

`            `val response = api.openConnection(

`                `OpenConnectionRequest(

`                    `comPort = port,

`                    `sspAddress = sspAddress,

`                    `enableAcceptor = false,   *// 连接时默认不启用接收*

`                    `enablePayout = true        *// 允许找零*

`                `)

`            `)

`            `\_isConnected = response.isOpen

`            `*// 连接成功后立即进行一次状态查询以初始化 \_lastStatus*

`            `\_lastStatus = getDeviceStatus()

`            `\_isConnected

`        `} catch (e: Exception) {

`            `*// 仅将异常转换为状态，不进行任何重试*

`            `\_lastStatus = DeviceStatus(online = false, errorCode = -1)

`            `false

`        `}

`    `}

`    `override suspend fun getDeviceStatus(): DeviceStatus {

`        `return try {

`            `*// 假设 API 提供了获取设备状态的接口*

`            `val status = api.getDeviceStatus(deviceId)

`            `DeviceStatus(online = true, errorCode = 0).also {

`                `\_lastStatus = it

`            `}

`        `} catch (e: Exception) {

`            `DeviceStatus(online = false, errorCode = -1).also {

`                `\_lastStatus = it

`            `}

`        `}

`    `}

`    `override suspend fun enableAcceptor(enable: Boolean): Boolean {

`        `return try {

`            `if (enable) {

`                `api.enableAcceptor(deviceId).isSuccessful

`            `} else {

`                `api.disableAcceptor(deviceId).isSuccessful

`            `}

`        `} catch (e: Exception) {

`            `false

`        `}

`    `}

`    `*/\*\**

`     `\* 获取当前各通道库存信息（用于找零评估）

`     `\* 对应 ITL SDK 的 GetCurrencyAssignment 接口

`     `\*/

`    `override suspend fun getCurrencyAssignment(): List<Denomination> {

`        `return try {

`            `val response = api.getCurrencyAssignment(deviceId)

`            `response.map { item ->

`                `Denomination(

`                    `value = item.value,

`                    `countryCode = item.countryCode,

`                    `stored = item.stored,

`                    `isRecyclable = item.isRecyclable,

`                    `channel = item.channel

`                `)

`            `}

`        `} catch (e: Exception) {

`            `*// 仅抛出异常，由状态管理层处理*

`            `throw CashDeviceException("GetCurrencyAssignment failed", e)

`        `}

`    `}

`    `override suspend fun dispenseChange(amountCents: Int): DispenseResult {

`        `return try {

`            `val result = api.dispenseValue(deviceId, amountCents)

`            `if (result.isSuccessful) {

`                `*// 根据业务逻辑解析结果*

`                `DispenseResult.Success

`            `} else {

`                `DispenseResult.HardwareError(result.errorBody()?.string() ?: "Unknown error")

`            `}

`        `} catch (e: Exception) {

`            `DispenseResult.HardwareError(e.message ?: "Network error")

`        `}

`    `}

`    `override suspend fun getChangeStatus(): ChangeStatus {

`        `return try {

`            `val levels = getCurrencyAssignment()

`            `val available = levels.filter { it.stored > 0 }.map { it.value }

`            `ChangeStatus(

`                `canMakeChange = available.isNotEmpty(),

`                `availableDenominations = available

`            `)

`        `} catch (e: Exception) {

`            `ChangeStatus(false, emptyList())

`        `}

`    `}

}

**A.3 模拟实现（单元测试/脱机演示）**

kotlin

*/\*\**

` `\* 纸币器模拟实现

` `\* 可用于单元测试、UI 脱机演示

` `\*/

class MockBillAcceptor : CashDevice {

`    `private var \_online = true

`    `private var \_acceptorEnabled = false

`    `private var \_levels = mutableMapOf(

`        `500L to 1,   *// 1 张 5€*

`        `1000L to 0,

`        `2000L to 2,  *// 2 张 20€*

`        `5000L to 0,

`        `10000L to 0,

`        `20000L to 0,

`        `50000L to 0

`    `)

`    `override val isOnline: Boolean get() = \_online

`    `override suspend fun openConnection(port: Int, sspAddress: Int): Boolean {

`        `\_online = true

`        `return true

`    `}

`    `override suspend fun getDeviceStatus(): DeviceStatus {

`        `return DeviceStatus(online = \_online, errorCode = 0)

`    `}

`    `override suspend fun enableAcceptor(enable: Boolean): Boolean {

`        `\_acceptorEnabled = enable

`        `return true

`    `}

`    `override suspend fun getCurrencyAssignment(): List<Denomination> {

`        `return \_levels.map { (value, stored) ->

`            `Denomination(

`                `value = value,

`                `countryCode = "EUR",

`                `stored = stored,

`                `isRecyclable = true,

`                `channel = 0

`            `)

`        `}

`    `}

`    `override suspend fun dispenseChange(amountCents: Int): DispenseResult {

`        `*// 模拟找零：简单检查是否有足够库存*

`        `val totalAvailable = \_levels.filterKeys { it <= 2000L }.values.sum()

`        `return if (totalAvailable >= amountCents) {

`            `*// 扣减库存（简化）*

`            `DispenseResult.Success

`        `} else {

`            `DispenseResult.InsufficientChange(amountCents - totalAvailable)

`        `}

`    `}

`    `override suspend fun getChangeStatus(): ChangeStatus {

`        `val available = \_levels.filter { it.value > 0 && it.key <= 2000L }.keys.toList()

`        `return ChangeStatus(

`            `canMakeChange = available.isNotEmpty(),

`            `availableDenominations = available

`        `)

`    `}

`    `fun setOffline() { \_online = false }

`    `fun addNote(value: Long) { \_levels[value] = \_levels.getOrDefault(value, 0) + 1 }

}

**A.4 状态管理层如何使用设备驱动**

**A.4.1 依赖注入（Hilt 示例）**

kotlin

@Module

@InstallIn(SingletonComponent::class)

object CashDeviceModule {

`    `@Provides

`    `@Singleton

`    `fun provideBillAcceptor(

`        `@CashDeviceApi retrofit: Retrofit

`    `): CashDevice {

`        `val api = retrofit.create(CashDeviceApi::class.java)

`        `return SpectralPayoutDevice(api)   *// 生产环境*

`        `*// return MockBillAcceptor()       // 脱机调试*

`    `}

`    `@Provides

`    `@Singleton

`    `fun provideCoinAcceptor(): CashDevice {

`        `*// 类似实现*

`    `}

}

**A.4.2 设备状态独立监测服务**

kotlin

@Singleton

class CashDeviceStatusMonitor @Inject constructor(

`    `private val billAcceptor: CashDevice,

`    `private val coinAcceptor: CashDevice,

`    `private val dispatcher: CoroutineDispatcher = Dispatchers.IO

) {

`    `private val \_billOnline = MutableStateFlow(true)

`    `val billOnline: StateFlow<Boolean> = \_billOnline.asStateFlow()

`    `private val \_coinOnline = MutableStateFlow(true)

`    `val coinOnline: StateFlow<Boolean> = \_coinOnline.asStateFlow()

`    `private var monitorJob: Job? = null

`    `fun startMonitoring(scope: CoroutineScope) {

`        `monitorJob = scope.launch(dispatcher) {

`            `while (isActive) {

`                `updateDeviceStatus()

`                `delay(500)  *// 500ms 间隔，符合厂商建议*

`            `}

`        `}

`    `}

`    `private suspend fun updateDeviceStatus() {

`        `\_billOnline.value = try {

`            `val status = billAcceptor.getDeviceStatus()

`            `status.online

`        `} catch (e: Exception) {

`            `false

`        `}

`        `\_coinOnline.value = try {

`            `val status = coinAcceptor.getDeviceStatus()

`            `status.online

`        `} catch (e: Exception) {

`            `false

`        `}

`        `*// 当任一设备连续离线超过阈值时，由状态管理层决策是否禁用现金支付*

`        `*// 此处仅更新状态，不包含任何重连逻辑*

`    `}

`    `fun stopMonitoring() {

`        `monitorJob?.cancel()

`        `monitorJob = null

`    `}

}

**A.4.3 支付流程中的轮询与超时处理**

kotlin

class PaymentViewModel @Inject constructor(

`    `private val cashDevice: CashDevice, *// 实际使用时应分别注入纸币器和硬币器，此处简化*

`    `private val statusMonitor: CashDeviceStatusMonitor

) : ViewModel() {

`    `private var pollingJob: Job? = null

`    `private var paidAmount = 0L          *// 已收金额（分）*

`    `private val targetAmount = MutableStateFlow(0L) *// 目标金额（分），由外部传入*

`    `*/\*\**

`     `\* 启动现金收款流程

`     `\* @param targetAmountCents 订单目标金额（分）

`     `\*/

`    `fun startCashPayment(targetAmountCents: Long) {

`        `targetAmount.value = targetAmountCents

`        `paidAmount = 0L

`        `viewModelScope.launch {

`            `*// 1. 确保设备状态正常（独立状态监测已保证在线，此处可再次确认）*

`            `*// 2. 启用接收器*

`            `cashDevice.enableAcceptor(true)

`            `*// 3. 轮询设备状态，获取现金事件*

`            `var consecutiveFailures = 0

`            `pollingJob = launch {

`                `while (isActive) {

`                    `try {

`                        `*// 获取设备状态及事件列表*

`                        `val status = cashDevice.getDeviceStatus()

`                        `*// 根据实际 API，可能需要从 status 中提取事件列表*

`                        `*// 假设 status 包含一个 events 字段或直接返回事件列表*

`                        `val events = status.events ?: emptyList()

`                        `consecutiveFailures = 0

`                        `processEvents(events)

`                        `if (paidAmount >= targetAmountCents) {

`                            `onPaymentSuccess()

`                            `break

`                        `}

`                    `} catch (e: Exception) {

`                        `consecutiveFailures++

`                        `if (consecutiveFailures >= MAX\_POLLING\_FAILURES) {

`                            `onPaymentTimeout()

`                            `break

`                        `}

`                    `}

`                    `delay(POLLING\_INTERVAL) *// 建议 200ms*

`                `}

`            `}.also { pollingJob = it }

`        `}

`    `}

`    `*/\*\**

`     `\* 解析事件列表，累加金额

`     `\*/

`    `private fun processEvents(events: List<DeviceEvent>) {

`        `for (event in events) {

`            `if (event.type == "CashEventResponse") {

`                `val cashEvent = event as? CashEventResponse ?: continue

`                `when (cashEvent.eventTypeAsString) {

`                    `"STORED", "STACKED", "VALUE\_ADDED", "COIN\_CREDIT" -> {

`                        `paidAmount += cashEvent.value

`                        `*// 通过 LiveData/Flow 更新 UI 显示应付、已付、差额*

`                        `\_paidAmountFlow.value = paidAmount

`                    `}

`                `}

`            `}

`        `}

`    `}

`    `private fun onPaymentSuccess() {

`        `viewModelScope.launch {

`            `cashDevice.enableAcceptor(false)  *// 关闭接收器*

`            `*// 注意：不再调用 collect()，金额已通过事件累加*

`        `}

`        `*// 更新状态机，跳转至 PaymentAuthorized*

`    `}

`    `private fun onPaymentTimeout() {

`        `viewModelScope.launch {

`            `cashDevice.enableAcceptor(false)

`        `}

`        `*// 触发取消支付流程，返回 PaymentSelecting*

`    `}

`    `companion object {

`        `private const val MAX\_POLLING\_FAILURES = 3

`        `private const val POLLING\_INTERVAL = 200L *// 毫秒*

`    `}

}

**A.5 与 V3.4 规范的一致性检查**

|规范要求|当前实现|
| :- | :- |
|设备层不含任何重试、重连逻辑|所有驱动方法仅执行单次请求，异常直接抛出或返回失败，无重试循环|
|连接仅建立一次|openConnection 仅在 APP 启动时由 CashDeviceManager 调用一次|
|状态监测独立轮询|CashDeviceStatusMonitor 以 500ms 间隔调用 getDeviceStatus|
|支付轮询超时由状态管理层控制|PaymentViewModel 捕获异常并计数，超过阈值后主动终止支付|
|设备状态缓存|驱动内部维护 lastStatus 并暴露 isOnline 属性|
|模拟实现|MockBillAcceptor 完整实现接口，支持脱机测试|

以上代码示例可直接集成至基于 Android Studio / Kotlin + Coroutines 的项目中，严格遵循 V3.4 规范关于设备层的所有约束。

**11. 票据系统与打印机配置产品规范**

**11.1 目标**

定义 V3.4 版本中：

- 小票数据结构规范
- 打印机配置管理规范
- 多语言输出规范
- 打印触发机制
- Device Test → Printer 页面设计要求

确保：

- 结构统一
- 配置统一
- 可国际化
- 可扩展
- 可稳定落地

**11.2 系统架构关系**

支付成功\
↓\
构建 ReceiptData\
↓\
读取 PrinterConfig\
↓\
根据字段开关构建打印内容\
↓\
按当前语言输出\
↓\
打印

**11.3 ReceiptData 数据结构规范**

ReceiptData 是**交易完成时的不可变数据快照**。

**11.3.1 数据模型定义（逻辑模型）**

|字段|类型|必填|说明|
| :- | :- | :- | :- |
|transactionId|String|是|唯一交易号|
|dateTime|String|是|交易完成时间|
|terminalId|String|否|终端编号|
|paymentMethod|Enum|是|CASH / POS|
|programName|String|是|套餐名称|
|unitPriceCents|Long|是|单价（分）|
|amountPaidCents|Long|是|实际支付金额|
|changeCents|Long|是|找零金额|
|status|Enum|是|SUCCESS|

**11.3.2 支付方式枚举**

|值|英语显示|德语显示|
| :- | :- | :- |
|CASH|Cash|Barzahlung|
|POS|Payment Card|Zahlungskarte|

⚠ POS 不再包含：

- CardType
- AuthCode
- RRN
- STAN

**11.4 PrinterConfig（打印机配置规范）**

PrinterConfig 统一存储在：\
Device Test → 打印机

**11.4.1 商户信息配置区**

|字段|必填|是否可隐藏|
| :- | :- | :- |
|Merchant Name|是|否|
|Address|否|是|
|Phone|否|是|

说明：

- Merchant Name 必须输入
- 不允许隐藏 Merchant Name
- Address / Phone 可隐藏

**11.4.2 打印字段控制区**

|控制项|默认值|说明|
| :- | :- | :- |
|显示地址|开|控制是否打印地址|
|显示电话|开|控制是否打印电话|
|显示 Terminal ID|开|控制是否打印终端号|

**11.4.3 页面结构设计（UI结构）**

text

Device Test

└── 打印机

`    `├── 商户信息

`    `│   ├── Merchant Name (必填)

`    `│   ├── Address

`    `│   └── Phone

`    `│

`    `├── 打印字段控制

`    `│   ├── [ ] 显示地址

`    `│   ├── [ ] 显示电话

`    `│   └── [ ] 显示 Terminal ID

`    `│

`    `└── 打印测试按钮

**11.5 80mm 打印排版规范**

**11.5.1 基础参数**

- 宽度：80mm
- 每行最大字符数：48
- 分隔线：48字符
- 金额右对齐
- 顶部底部使用 =

**11.5.2 英文模板**

text

\================================================

{Merchant Name}

{Address}

{Phone}

\================================================

Transaction ID   : {txId}

Date/Time        : {dateTime}

Terminal ID      : {terminalId}

Payment Method   : {Cash / Payment Card}

\------------------------------------------------

Program Name     : {programName}

Unit Price       : {price} EUR

\------------------------------------------------

Amount Paid      : {paid} EUR

Change Given     : {change} EUR

\------------------------------------------------

Status           : PAYMENT SUCCESS

\================================================

**11.5.3 德语模板**

text

\================================================

{Merchant Name}

{Address}

{Phone}

\================================================

Transaktions-ID  : {txId}

Datum/Uhrzeit    : {dateTime}

Terminal-ID      : {terminalId}

Zahlungsmethode  : {Barzahlung / Zahlungskarte}

\------------------------------------------------

Programmname     : {programName}

Preis            : {price} EUR

\------------------------------------------------

Bezahlt          : {paid} EUR

Rückgeld         : {change} EUR

\------------------------------------------------

Status           : ZAHLUNG ERFOLGREICH

\================================================

**11.6 多语言规范**

语言来源：系统当前 Locale

要求：

- 所有标题必须使用 string resources
- 不允许硬编码
- 金额格式按 Locale 自动格式化
- 日期格式按 Locale 输出

**11.7 打印触发机制（V3.4 最终规则）**

支付成功回调\
↓\
构建 ReceiptData\
↓\
立即打印

与：

- 洗车机寄存器
- GateCheck
- 启动信号

完全解耦。

**11.8 失败处理规范**

- 支付失败 → 不打印
- 打印失败 → 记录日志，不影响交易状态

**11.9 数据一致性要求**

ReceiptData 必须：

- 在支付成功瞬间生成
- 不允许后续修改
- 用于未来对账与查询

**11.10 V3.4 确认版本特征**

✔ 80mm 统一版式\
✔ POS 极简模式\
✔ 多语言\
✔ 配置集中在 Device Test\
✔ 打印与洗车解耦\
✔ 数据结构稳定

**11.11 未来扩展（V3.5 预留）**

- VAT
- 二维码
- 税号
- 客户编号
- 电子小票

**12. 后台管理模块规范**
## **12.1 模块入口结构**
首页右上角：

text

[ EN/DE ] [ Admin Console ] [ Device Test ]

点击：

- **Admin Console**：进入后台管理主界面，面向管理员和操作员。
- **Device Test**：进入设备测试与配置界面，面向管理员和技术人员。
## **12.2 Admin Console 内部结构**
text

Admin Console

├── 订单管理（Orders）

│   ├── 订单列表

│   ├── 订单详情

│   └── 异常订单处理（PendingSettlement）

├── 报表管理（Reports）

│   ├── 订单统计报表

│   ├── 金额统计报表

│   ├── 支付方式统计报表

│   └── 异常报表

├── 补币管理（Cash Replenishment）

│   ├── 纸币补充记录

│   ├── 硬币补充记录

│   └── 库存调整

└── 账户与权限（User Management）

`    `├── 用户列表

`    `├── 新增用户

`    `├── 角色权限配置

`    `└── 操作日志

**说明**：

- 订单管理：支持查看、搜索、筛选订单，处理异常挂起订单（PendingSettlement）。
- 报表管理：提供多种统计报表，支持 CSV/PDF 导出。
- 补币管理：记录纸币/硬币的补充操作，调整库存，用于对账和零钱预警。
- 账户与权限：管理后台用户账号、角色权限，记录操作日志。
## **12.3 Device Test 内部结构**
Device Test 独立于 Admin Console，用于设备调试、状态监控和配置。其结构如下：

text

Device Test

├── PLC 状态监控（PLC Monitor）

│   ├── 实时寄存器查看（217/240/214/102/752）

│   ├── 强制指令发送（M60/M71，仅供调试）

│   └── 历史事件日志

├── 现金设备（Cash Devices）

│   ├── 纸币器（Bill Acceptor）

│   │   ├── 设备状态（在线/故障/卡币等）

│   │   ├── 库存查看（各面额数量明细）

│   │   ├── 可找零面额设定（每个面额独立开关，开启/禁用找零）

│   │   └── SmartEmpty 按钮（功能待定义，如智能清空回收箱）

│   ├── 硬币器（Coin Acceptor）

│   │   ├── 设备状态（在线/故障/卡币等）

│   │   ├── 库存查看（各面额数量明细）

│   │   ├── 可找零面额设定（每个面额独立开关，开启/禁用找零）

│   │   └── SmartEmpty 按钮（功能待定义，如智能清空回收箱）

│   └── （可选）整体健康状态仪表盘（简化为设备状态汇总）

├── 打印机（Printer）

│   ├── 商户信息配置

│   │   ├── Merchant Name（必填）

│   │   ├── Address（可选）

│   │   └── Phone（可选）

│   ├── 打印字段控制

│   │   ├── 显示地址（开关）

│   │   ├── 显示电话（开关）

│   │   └── 显示 Terminal ID（开关）

│   └── 打印测试按钮

└── 洗车模式配置（Wash Mode Config）

`    `├── Mode1（Basic Wash）启用/禁用

`    `├── Mode2（Standard Wash）启用/禁用

`    `├── Mode3（Premium Wash）启用/禁用

`    `├── Mode4（VIP Wash）启用/禁用

`    `└── 模式名称本地化（英语/德语）编辑

**说明**：

- PLC 状态监控：用于技术人员实时观察 PLC 寄存器值，诊断故障。
- 现金设备：提供纸币器/硬币器的核心维护功能，重点在于库存查看和可找零面额设定，简化不必要的测试功能。
  - 设备状态：显示在线/离线、故障类型（如卡币、钱箱移除等）。
  - 库存查看：显示当前零箱中各面额的库存数量（与 ITL SDK 的 GetCurrencyAssignment 返回的 stored 字段一致）。
  - 可找零面额设定：为每个面额提供独立开关，管理员可控制该面额是否允许用于找零。此设定将影响 Change Guard 模块的决策（即该面额在 Denomination 中的 isRecyclable 或类似标志）。默认所有可回收面额均允许找零。
  - SmartEmpty 按钮：预留功能，具体行为由运营需求定义（例如将回收箱中的钱转入钱箱，或清空找零箱以备维护）。该按钮触发后应记录操作日志。
- 打印机：配置商户信息和打印字段，与第11章规范一致。
- 洗车模式配置：控制哪些洗车套餐在 APP 中可用，并可编辑其显示名称（支持多语言）。底层 MODE 指令与 PLC 地址的对应关系固定，不可在此修改。

  **12.4 账户与权限管理规范**

  **12.4.1 账号在哪里设定？**

  路径：\
  Admin Console → 账户与权限\
  只有 Admin 可以访问。

  **12.4.2 账号字段定义**

  |字段|类型|来源|
  | :- | :- | :- |
  |userId|UUID|系统生成|
  |username|String|管理员创建|
  |passwordHash|String|系统加密|
  |role|ADMIN / OPERATOR / TECHNICIAN|管理员设定|
  |isActive|Boolean|管理员控制|
  |createdAt|Long|系统生成|

  **12.4.3 默认账号规则**

  首次安装时：

  - 默认创建一个 Admin 账号
  - 强制修改密码

**12.4.4 权限矩阵**

|功能|Admin|Operator|Technician|
| :- | :- | :- | :- |
|进入 Admin Console|✅|✅|❌|
|订单管理|✅|✅|❌|
|报表管理|✅|✅|❌|
|账户管理|✅|❌|❌|
|Device Test|✅|❌|✅|
|手动退款|✅|❌|❌|
|关账|✅|❌|❌|

**12.5 订单管理规范**

路径：\
Admin Console → 订单管理

**12.5.1 订单列表字段**

|字段|来源|
| :- | :- |
|orderId|Order 表|
|createdAt|Order 表|
|priceCents|Order 表|
|paidCents|Order 表|
|changeCents|Order 表|
|paymentMethod|Order 表|
|state|Order 表|
|failureReasonCode|Order 表|
|operatorId|Order 表|
|completedAt|Order 表|

**12.5.2 订单详情字段**

分为 4 区域：

**① 基础信息**

|字段|来源|
| :- | :- |
|orderId|Order|
|sessionId|PaymentSession|
|createdAt|Order|
|updatedAt|Order|

**② 金额信息**

|字段|来源|
| :- | :- |
|priceCents|Order|
|paidCents|PaymentSession|
|changeCents|PaymentSession|
|净收入|priceCents|

**③ 支付信息**

|字段|来源|
| :- | :- |
|paymentMethod|Order|
|支付开始时间|PaymentSession|
|支付完成时间|PaymentSession|
|支付状态|PaymentSession|

**④ 审计日志**

来源：

- 操作日志表
- 支付事件日志表

**12.6 报表管理规范**

路径：\
Admin Console → 报表管理

**12.6 报表字段与来源**

**12.6.1 订单统计报表**

统计字段：

|字段|来源|
| :- | :- |
|订单总数|count(Order)|
|已支付数|state=ORDER\_PAID|
|取消数|state=ORDER\_CANCELLED|
|失败数|state=ORDER\_FAILED|
|PendingSettlement|state=ORDER\_MANUAL|

**12.6.2 金额统计报表**

|字段|计算方式|
| :- | :- |
|总应收|sum(priceCents)|
|总已收|sum(paidCents)|
|总找零|sum(changeCents)|
|净收入|sum(priceCents where PAID/COMPLETED)|

**12.6.3 支付方式统计**

|字段|计算方式|
| :- | :- |
|现金总额|sum(paidCents where paymentMethod=CASH)|
|POS总额|sum(paidCents where paymentMethod=POS)|

**12.6.4 异常报表字段**

|字段|来源|
| :- | :- |
|orderId|Order|
|state|Order|
|failureReasonCode|Order|
|manualResolution|Order|
|operatorId|Order|
|处理时间|updatedAt|

**12.7 报表导出**

支持：

- CSV
- PDF
- 日结
- 月结

导出口径：

- 仅包含已支付和完成订单
- 包含退款与异常标记

**12.8 数据来源总结**

|模块|数据来源|
| :- | :- |
|订单列表|Order 表|
|支付信息|PaymentSession 表|
|报表统计|Order + PaymentSession|
|审计日志|OperationLog 表|
|用户权限|User 表|

**12.9 关账规则**

关账前必须：

- 所有 PendingSettlement 处理完毕
- 所有手动退款标记完成

否则：\
状态 = UNBALANCED

**12.10 V3.4 后台结构最终确认**

✔ Admin Console 入口清晰\
✔ 订单与报表统一管理\
✔ 账号统一在 Admin Console 内设定\
✔ 权限 RBAC 清晰\
✔ 字段来源明确\
✔ 财务口径一致

